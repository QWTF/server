.float h_i_g, r_i_g, a_s, a_n, a_r, a_c, rv_s_h, rs_s_h, rv_gr, rs_gr, rs_g;
.float rv_g;
.vector goal_min, goal_max;

.string old_model;			// Added by XavioR

.entity tent;

// Prototypes
// Team Functions
void(float tno, float scoretoadd) TeamFortress_TeamIncreaseScore;
void(float all) TeamFortress_TeamShowScores;
float() TeamFortress_TeamGetWinner;

// Functions to handle entity placement when spawned
void() TF_PlaceItem;
void() TF_StartItem;
void() TF_PlaceGoal;
void() TF_StartGoal;

// Spawn functions for all Map Entities
float() CheckExistence;
void() info_tfdetect;
void() info_player_teamspawn;
void() info_tfgoal;
void() info_tfgoal_timer;
void() item_tfgoal;

// AutoDetection Function
void(entity AD) ParseTFDetect;

// Generic Functions
entity(float ino) Finditem;
entity(float gno) Findgoal;
entity(float gno) Findteamspawn;
void(entity Goal) InactivateGoal;
void(entity Goal) RestoreGoal;
void(entity Goal) RemoveGoal;
float(entity Goal, entity Player, entity AP) IsAffectedBy;
void(entity Goal, entity Player, entity AP, float addb) Apply_Results;
float(entity Goal, entity AP) APMeetsCriteria;
void(entity Goal) SetupRespawn;
void() DoRespawn;
void(entity Goal, entity AP) DoGoalWork;
void(entity Goal, entity AP) DoGroupWork;
void(entity Item, entity AP) DoItemGroupWork;
void(entity Goal, entity AP) DoTriggerWork;
void(entity Goal, entity AP, float addb) DoResults;
void(entity Goal, entity Player) RemoveResults;

// Goal Functions
void() tfgoal_touch;
void() info_tfgoal_use;

// Timer Goal Functions
void() tfgoal_timer_tick;

// Item Functions
void() item_tfgoal_touch;
void(entity Item, entity AP, entity Goal) tfgoalitem_GiveToPlayer;
void(entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer;
void() tfgoalitem_remove;
#ifdef clan_progs
void (entity Item, float PAlive, entity P) tfgoalitem_drop;
#else
void(entity Item) tfgoalitem_drop;
#endif
void(entity Item) tfgoalitem_checkgoalreturn;
void() ReturnItem;
void(entity Goal, entity Player, entity Item) DisplayItemStatus;

// CTF Support Functions
void() CTF_FlagCheck;


void () TF_PlaceItem;
void () TF_StartItem;
void () TF_PlaceGoal;
void () TF_StartGoal;
//void () TF_PlaceCamp;
//void () TF_StartCamp;
void () info_tfdetect;
//void () info_tfnocamp;
void () info_player_teamspawn;
void () info_tfgoal;
void () info_tfgoal_timer;
void () item_tfgoal;
entity (float gno) Findgoal;
entity (float gno) Findteamspawn;
void (entity Goal) InactivateGoal;
void (entity Goal) RestoreGoal;
void (entity Goal) RemoveGoal;
float (entity Goal,entity Player,entity AP) IsAffectedBy;
void (entity Goal,entity Player,entity AP,float addb) Apply_Results;
float (entity Goal,entity AP) APMeetsCriteria;
void (entity Goal) SetupRespawn;
void () DoRespawn;
void (entity Item,entity AP) DoItemGroupWork;
void (entity Goal,entity AP) DoTriggerWork;
void (entity Goal,entity Player) RemoveResults;
void () info_tfgoal_use;
void () tfgoal_timer_tick;
void () item_tfgoal_touch;
void () tfgoalitem_remove;
//void (entity Item) tfgoalitem_drop;
void (entity Item) tfgoalitem_checkgoalreturn;
void () ReturnItem;
#ifdef fte_rankings
// Rankings -- add points for capturing the flag
void (entity rank_ent, float addscore) Rank_AddCaps;
#endif

void() MoveFlag = 
{

	if ( (prematch) )// && (self.owner.items & 131072) )
	{
		T_Damage (self.owner, self.owner, self.owner, 500);
	}

	makevectors(self.owner.v_angle);
	setorigin(self, self.owner.origin - v_forward * 25 + '0 0 20');
	self.angles_x = self.owner.angles_z;
	self.angles_y = self.owner.angles_y + 90;
	self.angles_z = TF_FLARE_LIT - self.owner.angles_x;
	self.nextthink = time + 0.010000;
	self.think = MoveFlag;
	if (self.owner.deadflag)
	{
		// pablo
		//self.movetype = 10;
		//self.velocity = '0 0 100';
		//
		self.owner.effects = self.owner.effects - (self.owner.effects & 128);
		self.owner.effects = self.owner.effects - (self.owner.effects & 64);
		dremove(self);
	}
	if (!(self.owner.items & 131072) && !(self.owner.items & 262144))
	{
		self.owner.effects = self.owner.effects - (self.owner.effects & 128);
		self.owner.effects = self.owner.effects - (self.owner.effects & 64);
		dremove(self);
	}
};

void(entity Goal) UpdateAbbreviations = 
{
	if (Goal.has_disconnected == TF_FLARE_LIT)
	{
		if (Goal.g_a != TF_FLARE_LIT && Goal.goal_activation == TF_FLARE_LIT)
		{
			Goal.goal_activation = Goal.g_a;
		}
		if (Goal.g_e != TF_FLARE_LIT && Goal.goal_effects == TF_FLARE_LIT)
		{
			Goal.goal_effects = Goal.g_e;
		}
		if (Goal.h_i_g != TF_FLARE_LIT && Goal.has_item_from_group == TF_FLARE_LIT)
		{
			Goal.has_item_from_group = Goal.h_i_g;
		}
		if (Goal.r_i_g != TF_FLARE_LIT && Goal.remove_item_group == TF_FLARE_LIT)
		{
			Goal.remove_item_group = Goal.r_i_g;
		}
		if (Goal.a_s != TF_FLARE_LIT && Goal.ammo_shells == TF_FLARE_LIT)
		{
			Goal.ammo_shells = Goal.a_s;
		}
		if (Goal.a_n != TF_FLARE_LIT && Goal.ammo_nails == TF_FLARE_LIT)
		{
			Goal.ammo_nails = Goal.a_n;
		}
		if (Goal.a_r != TF_FLARE_LIT && Goal.ammo_rockets == TF_FLARE_LIT)
		{
			Goal.ammo_rockets = Goal.a_r;
		}
		if (Goal.a_c != TF_FLARE_LIT && Goal.ammo_cells == TF_FLARE_LIT)
		{
			Goal.ammo_cells = Goal.a_c;
		}
		if (Goal.rv_s_h != TF_FLARE_LIT && Goal.remove_spawngroup == TF_FLARE_LIT)
		{
			Goal.remove_spawngroup = Goal.rv_s_h;
		}
		if (Goal.rs_s_h != TF_FLARE_LIT && Goal.restore_spawngroup == TF_FLARE_LIT)
		{
			Goal.restore_spawngroup = Goal.rs_s_h;
		}
		if (Goal.rv_gr != TF_FLARE_LIT && Goal.remove_group_no == TF_FLARE_LIT)
		{
			Goal.remove_group_no = Goal.rv_gr;
		}
		if (Goal.rs_gr != TF_FLARE_LIT && Goal.restore_group_no == TF_FLARE_LIT)
		{
			Goal.restore_group_no = Goal.rs_gr;
		}
		if (Goal.rs_g != TF_FLARE_LIT && Goal.restore_goal_no == TF_FLARE_LIT)
		{
			Goal.restore_goal_no = Goal.rs_g;
		}
		if (Goal.rv_g != TF_FLARE_LIT && Goal.remove_goal_no == TF_FLARE_LIT)
		{
			Goal.remove_goal_no = Goal.rv_g;
		}
		if (Goal.t_s_h != string_null)
		{
			Goal.team_str_home = Goal.t_s_h;
		}
		if (Goal.t_s_m != string_null)
		{
			Goal.team_str_moved = Goal.t_s_m;
		}
		if (Goal.t_s_c != string_null)
		{
			Goal.team_str_carried = Goal.t_s_c;
		}
		if (Goal.n_s_h != string_null)
		{
			Goal.non_team_str_home = Goal.n_s_h;
		}
		if (Goal.n_s_m != string_null)
		{
			Goal.non_team_str_moved = Goal.n_s_m;
		}
		if (Goal.n_s_c != string_null)
		{
			Goal.non_team_str_carried = Goal.n_s_c;
		}
		if (Goal.b_b != string_null)
		{
			Goal.broadcast = Goal.b_b;
		}
		if (Goal.b_t != string_null)
		{
			Goal.team_broadcast = Goal.b_t;
		}
		if (Goal.b_n != string_null)
		{
			Goal.non_team_broadcast = Goal.b_n;
		}
		if (Goal.b_o != string_null)
		{
			Goal.owners_team_broadcast = Goal.b_o;
		}
		if (Goal.n_b != string_null)
		{
			Goal.netname_broadcast = Goal.n_b;
		}
		if (Goal.n_t != string_null)
		{
			Goal.netname_team_broadcast = Goal.n_t;
		}
		if (Goal.n_n != string_null)
		{
			Goal.netname_non_team_broadcast = Goal.n_n;
		}
		if (Goal.n_o != string_null)
		{
			Goal.netname_owners_team_broadcast = Goal.n_o;
		}
		if (Goal.d_t != string_null)
		{
			Goal.team_drop = Goal.d_t;
		}
		if (Goal.d_n != string_null)
		{
			Goal.non_team_drop = Goal.d_n;
		}
		if (Goal.d_n_t != string_null)
		{
			Goal.netname_team_drop = Goal.d_n_t;
		}
		if (Goal.d_n_n != string_null)
		{
			Goal.netname_non_team_drop = Goal.d_n_n;
		}
		Goal.has_disconnected = TF_FLARE_OFF;
	}
};

void() TF_PlaceItem = 
{
	self.flags = 256;
	self.movetype = TF_FLARE_LIT;
	self.velocity = '0 0 0';
	self.oldorigin = self.origin;
	if (self.goal_activation & 512)
	{
		self.effects = self.effects | 8;
	}
	if (item_list_bit == TF_FLARE_LIT)
	{
		item_list_bit = TF_FLARE_OFF;
	}
	self.item_list = item_list_bit;
	item_list_bit = item_list_bit * 2;
};

void() TF_StartItem = 
{
	UpdateAbbreviations(self);
	self.nextthink = time + 0.2;
	self.think = TF_PlaceItem;
	if (self.goal_state == 3)
	{
		RemoveGoal(self);
	}
};

void() TF_PlaceGoal = 
{	
	if (self.classname != "info_tfgoal_timer")
	{
		if (self.goal_activation & TF_FLARE_OFF)
		{
			self.touch = tfgoal_touch;
		}
	}
	else
	{
		self.think = tfgoal_timer_tick;
		self.nextthink = time + self.search_time;
		self.classname = "info_tfgoal";
	}
	self.flags = 256;
	self.movetype = TF_FLARE_LIT;
	self.velocity = '0 0 0';
	self.oldorigin = self.origin;
};

void() TF_StartGoal = 
{
	UpdateAbbreviations(self);
	self.nextthink = time + 0.2;
	self.think = TF_PlaceGoal;
	self.use = info_tfgoal_use;
	if (self.goal_state == 3)
	{
		RemoveGoal(self);
	}
};

float() CheckExistence = 
{
	UpdateAbbreviations(self);
	if (self.ex_skill_min && skill <= self.ex_skill_min)
	{
		return TF_FLARE_LIT;
	}
	else
	{
		if (self.ex_skill_max && skill >= self.ex_skill_max)
		{
			return TF_FLARE_LIT;
		}
	}
	return TF_FLARE_OFF;
};

void () info_tfdetect = 
{
   local entity te;
   local string st;

   UpdateAbbreviations (self);

   //TIMELEFT TIMER
   te = find (world,classname,"countdown");
   if (te != world) 
   { 
	   return;
   }

   st = infokey (world,"time");
   if (st == "off")
   {
	   return;
   }
   newmis = spawn ();
   newmis.classname = "countdown";
   newmis.no_grenades_1 = 0;
   st = infokey (world,"timelimit");
   newmis.health = stof(st);
   newmis.think = review_timeleft;
   newmis.nextthink = (time + 1);

// MESSAGE DISP CODE
	if (haltloop1 != 1) {
	local string msg1timer;

	msg1timer = infokey (world, "svmsg1");
	msg1time = stof(msg1timer);

	if (msg1time > 0)
	{
		display_message ();
	}
	haltloop1 = 1;
	}

	if (haltloop2 != 1) {
	local string msg2timer;

	msg2timer = infokey (world, "svmsg2");
	msg2time = stof(msg2timer);

	if (msg2time > 0)
	{
		pre_messagetimer2 ();
	}
	haltloop1 = 1;
	}
};

/* Gold.  this is the old info_tfdetect... new one is above
void() info_tfdetect = 
{
	UpdateAbbreviations(self);
	//gold. next 6 lines are part of plexi's code for the "timeleft" command.
	newmis = spawn ();
	newmis.classname = "countdown";
	newmis.netname = "countdown";
	newmis.no_grenades_1 = 0;
	newmis.think = review_timeleft;
	newmis.nextthink = (time + 1);
};
*/
void() info_player_teamspawn = 
{
	local entity te;
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (number_of_teams < self.team_no)
	{
		number_of_teams = self.team_no;
	}
	if (self.team_no <= TF_FLARE_LIT)
	{
		dprint("no team_no associated with info_player_teamspawn\n");
		dremove(self);
	}
	if (self.items != TF_FLARE_LIT)
	{
		te = Finditem(self.items);
		if (!te)
		{
			dprint("info_player_teamspawn specifies a GoalItem that does not exist\n");
			dremove(self);
		}
	}
	if (self.team_no == TF_FLARE_OFF)
	{
		self.team_str_home = "ts1";
	}
	else
	{
		if (self.team_no == 2)
		{
			self.team_str_home = "ts2";
		}
		else
		{
			if (self.team_no == 3)
			{
				self.team_str_home = "ts3";
			}
			else
			{
				if (self.team_no == 4)
				{
					self.team_str_home = "ts4";
				}
			}
		}
	}
};

void() i_p_t = 
{
	self.classname = "info_player_teamspawn";
	info_player_teamspawn();
};

void() info_tfgoal = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (self.mdl)
	{
		precache_model(self.mdl);
		precache_model2(self.mdl);
		setmodel(self, self.mdl);
	}
	if (self.noise)
	{
		precache_sound(self.noise);
		precache_sound2(self.noise);
	}
	else
	{
		if (self.mdl == "progs/backpack.mdl")
		{
			precache_sound("items/backpack.wav");
			precache_sound2("items/backpack.wav");
			self.noise = "items/backpack.wav";
		}
	}
	precache_sound("items/protect.wav");
	precache_sound("items/protect2.wav");
	precache_sound("items/protect3.wav");
	precache_sound("items/suit.wav");
	precache_sound("items/suit2.wav");
	precache_sound("items/inv1.wav");
	precache_sound("items/inv2.wav");
	precache_sound("items/inv3.wav");
	precache_sound("items/damage.wav");
	precache_sound("items/damage2.wav");
	precache_sound("items/damage3.wav");
	self.solid = TF_FLARE_OFF;
	if (self.goal_state == TF_FLARE_LIT)
	{
		self.goal_state = 2;
	}
	if (self.goal_min != '0 0 0')
	{
		setsize(self, self.goal_min, self.goal_max);
	}
	else
	{
		setsize(self, '-16 -16 -24', '16 16 32');
	}
	TF_StartGoal();
};

void() i_t_g = 
{
	self.classname = "info_tfgoal";
	info_tfgoal();
};

void() info_tfgoal_timer = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (self.mdl)
	{
		precache_model(self.mdl);
		precache_model2(self.mdl);
		setmodel(self, self.mdl);
	}
	if (self.noise)
	{
		precache_sound(self.noise);
		precache_sound2(self.noise);
	}
	if (self.search_time <= TF_FLARE_LIT)
	{
		dprint("Timer Goal created with no specified time.\n");
		dremove(self);
	}
	self.solid = TF_FLARE_LIT;
	if (self.goal_state == TF_FLARE_LIT)
	{
		self.goal_state = 2;
	}
	setsize(self, '-16 -16 -24', '16 16 32');
	TF_StartGoal();
};

void() i_t_t = 
{
	self.classname = "info_tfgoal_timer";
	info_tfgoal_timer();
};

void() item_tfgoal = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (self.mdl)
	{
		precache_model(self.mdl);
		precache_model2(self.mdl);
		setmodel(self, self.mdl);
	}
	else
	{
		self.mdl = "";
		setmodel(self, "");
	}
	precache_sound2("items/itembk2.wav");
	if (self.noise)
	{
		precache_sound(self.noise);
		precache_sound2(self.noise);
	}
	self.touch = item_tfgoal_touch;
	if (self.goal_state == TF_FLARE_LIT)
	{
		self.goal_state = 2;
	}
	self.solid = TF_FLARE_OFF;
	setorigin(self, self.origin);
	if (!(self.netname))
	{
		self.netname = "goalitem";
	}
	if (self.pausetime <= TF_FLARE_LIT)
	{
		self.pausetime = 60;
	}
	if (self.delay != TF_FLARE_LIT && self.pausetime == TF_FLARE_LIT)
	{
		self.pausetime = self.delay;
	}
	setsize(self, '-16 -16 -24', '16 16 32');
	TF_StartItem();
};

void(entity AD) ParseTFDetect = 
{
	local string mtf_ver;
	local string mtf_website;
	mtf_ver = #mtf_Ver;		// #mtf_Ver defined in defs.pqc now..
	mtf_website = #mtf_Website;

	if (AD.team_broadcast != string_null)
	{
		team_menu_string = AD.team_broadcast;
	}
	localcmd(AD.message);
	localcmd("serverinfo ");
	localcmd("MegaTF v");
	localcmd(mtf_ver);
	
	sprint (self, 2, "\nQuakeWorld MegaTeamFortress v", mtf_ver);
	
	
#ifdef clan_progs
	localcmd("CE");
	sprint (self, 2, "CE");
#endif
	
	sprint (self, 2, "\n", mtf_website, "\n\n");
	
	localcmd("\n");
	team1lives = AD.ammo_shells;
	team2lives = AD.ammo_nails;
	team3lives = AD.ammo_rockets;
	team4lives = AD.ammo_cells;
	if (team1lives == TF_FLARE_LIT)
	{
		team1lives = -1;
	}
	if (team2lives == TF_FLARE_LIT)
	{
		team2lives = -1;
	}
	if (team3lives == TF_FLARE_LIT)
	{
		team3lives = -1;
	}
	if (team4lives == TF_FLARE_LIT)
	{
		team4lives = -1;
	}
	if (AD.hook_out == TF_FLARE_OFF)
	{
		allow_hook = TF_FLARE_LIT;
	}
	team1maxplayers = AD.ammo_medikit;
	team2maxplayers = AD.ammo_detpack;
	team3maxplayers = AD.maxammo_medikit;
	team4maxplayers = AD.maxammo_detpack;
	if (team1maxplayers == TF_FLARE_LIT)
	{
		team1maxplayers = 30;
	}
	if (team2maxplayers == TF_FLARE_LIT)
	{
		team2maxplayers = 30;
	}
	if (team3maxplayers == TF_FLARE_LIT)
	{
		team3maxplayers = 30;
	}
	if (team4maxplayers == TF_FLARE_LIT)
	{
		team4maxplayers = 30;
	}
	illegalclasses = AD.playerclass;
	illegalclasses1 = AD.maxammo_shells;
	illegalclasses2 = AD.maxammo_nails;
	illegalclasses3 = AD.maxammo_rockets;
	illegalclasses4 = AD.maxammo_cells;
	if (mapname == "1on1r")
	{
		illegalclasses1 = 419;
		illegalclasses2 = 419;
	}
	if (mapname == "2FORT5")
	{
		localcmd("sv_gravity 800\n");
	}
	if (((AD.message == "engbat\n") || (mapname == "engbat")))
	{
		engbat = 1;
		bprint (1, "engbat mode on\n");
	}
	else
	{
		engbat = 0;
	}
	civilianteams = TF_FLARE_LIT;
	if (illegalclasses1 == -1)
	{
		illegalclasses1 = TF_FLARE_LIT;
		civilianteams = civilianteams | TF_FLARE_OFF;
	}
	if (illegalclasses2 == -1)
	{
		illegalclasses2 = TF_FLARE_LIT;
		civilianteams = civilianteams | 2;
	}
	if (illegalclasses3 == -1)
	{
		illegalclasses3 = TF_FLARE_LIT;
		civilianteams = civilianteams | 4;
	}
	if (illegalclasses4 == -1)
	{
		illegalclasses4 = TF_FLARE_LIT;
		civilianteams = civilianteams | 8;
	}
};

entity(float ino) Finditem = 
{
	local entity tg;
	local string st;
	tg = find(world, classname, "item_tfgoal");
	while (tg)
	{
		if (tg.goal_no == ino)
		{
			return tg;
		}
		tg = find(tg, classname, "item_tfgoal");
	}
	dprint("Could not find an item with a goal_no of ");
	st = ftos(ino);
	dprint(st);
	dprint(".\n");
	return world;
};

entity(float gno) Findgoal = 
{
	local entity tg;
	local string st;
	tg = find(world, classname, "info_tfgoal");
	while (tg)
	{
		if (tg.goal_no == gno)
		{
			return tg;
		}
		tg = find(tg, classname, "info_tfgoal");
	}
	dprint("Could not find a goal with a goal_no of ");
	st = ftos(gno);
	dprint(st);
	dprint(".\n");
	return tg;	// dirty fix!!
};

entity(float gno) Findteamspawn = 
{
	local entity tg;
	local string st;
	tg = find(world, classname, "info_player_teamspawn");
	while (tg)
	{
		if (tg.goal_no == gno)
		{
			return tg;
		}
		tg = find(tg, classname, "info_player_teamspawn");
	}
	dprint("Could not find a Teamspawn with a goal_no of ");
	st = ftos(gno);
	dprint(st);
	dprint(".\n");
	return tg;	// DIRTY FIX!!!
};

void(entity Goal) InactivateGoal = 
{
	if (Goal.goal_state == TF_FLARE_OFF)
	{
		if (Goal.search_time == TF_FLARE_LIT)
		{
			Goal.solid = TF_FLARE_OFF;
		}
		Goal.goal_state = 2;
		if (Goal.mdl != string_null)
		{
			setmodel(Goal, Goal.mdl);
		}
	}
};

void(entity Goal) RestoreGoal = 
{
	if (Goal.goal_state == 3)
	{
		if (Goal.search_time == TF_FLARE_LIT)
		{
			Goal.solid = TF_FLARE_OFF;
		}
		else
		{
			Goal.nextthink = time + Goal.search_time;
		}
		Goal.goal_state = 2;
		if (Goal.mdl != string_null)
		{
			setmodel(Goal, Goal.old_model);
		}
	}
};

void(entity Goal) RemoveGoal = 
{
	Goal.solid = TF_FLARE_LIT;
	Goal.goal_state = 3;
	if (Goal.mdl != string_null)
	{
		Goal.old_model = Goal.mdl;
		setmodel(Goal, string_null);
	}
};

float(entity Goal, entity Player, entity AP) IsAffectedBy = 
{
	local float genv;
	if (Player.playerclass == TF_FLARE_LIT)
	{
		return TF_FLARE_LIT;
	}
	if (Goal.goal_effects & 32)
	{
		genv = pointcontents(Goal.origin);
		if (pointcontents(Player.origin) != genv)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.t_length != TF_FLARE_LIT)
	{
		if (vlen(Goal.origin - Player.origin) <= Goal.t_length)
		{
			if (Goal.goal_effects & 16)
			{
				traceline(Goal.origin, Player.origin, TF_FLARE_OFF, Goal);
				if (trace_fraction == TF_FLARE_OFF)
				{
					return TF_FLARE_OFF;
				}
			}
			else
			{
				return TF_FLARE_OFF;
			}
		}
	}
	if (Goal.classname != "info_tfgoal_timer")
	{
		if (Goal.goal_effects & TF_FLARE_OFF && Player == AP)
		{
			return TF_FLARE_OFF;
		}
		if (Goal.goal_effects & 2 && AP.team_no == Player.team_no)
		{
			return TF_FLARE_OFF;
		}
		if (Goal.goal_effects & 4 && AP.team_no != Player.team_no)
		{
			return TF_FLARE_OFF;
		}
		if (Goal.goal_effects & 8 && Player != AP)
		{
			return TF_FLARE_OFF;
		}
	}
	if (Goal.maxammo_shells != TF_FLARE_LIT && Player.team_no == Goal.maxammo_shells)
	{
		return TF_FLARE_OFF;
	}
	if (Goal.maxammo_nails != TF_FLARE_LIT && Player.team_no != Goal.maxammo_shells)
	{
		return TF_FLARE_OFF;
	}
	return TF_FLARE_LIT;
};

void(entity Goal, entity Player, entity AP, float addb) Apply_Results = 
{
	local entity oldself;
	local entity te;
	local entity oldte;
	local float oa;
	stuffcmd(Player, "bf\n");
	if (Goal.classname == "item_tfgoal")
	{
		Player.item_list = Player.item_list | Goal.item_list;
	}
	if (Player == AP)
	{
		if (Goal.count != TF_FLARE_LIT)
		{
			if (Player.team_no > TF_FLARE_LIT)
			{
				TeamFortress_TeamIncreaseScore(Player.team_no, Goal.count);
				TeamFortress_TeamShowScores(2);
			}
		}
	}
	if (addb)
	{
		if (Player.health > TF_FLARE_LIT)
		{
			if (Goal.health > TF_FLARE_LIT)
			{
				T_Heal(Player, Goal.health, TF_FLARE_LIT);
			}
			if (Goal.health < TF_FLARE_LIT)
			{
				if (TF_FLARE_LIT - Player.health > Goal.health)
				{
					Player.armorvalue = TF_FLARE_LIT;
					T_Damage(Player, Goal, Goal, Player.health + TF_FLARE_OFF);
				}
				else
				{
					oa = Player.armorvalue;
					Player.armorvalue = TF_FLARE_LIT;
					T_Damage(Player, Goal, Goal, TF_FLARE_LIT - Goal.health);
					Player.armorvalue = oa;
				}
			}
		}
		if (Player.health > TF_FLARE_LIT)
		{
			if (Goal.armortype)
			{
				Player.armortype = Goal.armortype;
			}
			Player.armorvalue = Player.armorvalue + Goal.armorvalue;
			if (Goal.armorclass)
			{
				Player.armorclass = Goal.armorclass;
			}
			if (Goal.gravity > TF_FLARE_LIT)
			{
				Player.gravity = Goal.gravity;
			}
			Player.ammo_shells = Player.ammo_shells + Goal.ammo_shells;
			Player.ammo_nails = Player.ammo_nails + Goal.ammo_nails;
			Player.ammo_rockets = Player.ammo_rockets + Goal.ammo_rockets;
			Player.ammo_cells = Player.ammo_cells + Goal.ammo_cells;
			Player.ammo_medikit = Player.ammo_medikit + Goal.ammo_medikit;
			Player.ammo_detpack = Player.ammo_detpack + Goal.ammo_detpack;
			Player.no_grenades_1 = Player.no_grenades_1 + Goal.no_grenades_1;
			Player.no_grenades_2 = Player.no_grenades_2 + Goal.no_grenades_2;
			if (Player.no_grenades_1 > 4)
			{
				Player.no_grenades_1 = 4;
			}
			if (Player.no_grenades_2 > 4)
			{
				Player.no_grenades_2 = 4;
			}
			if (Player.ammo_detpack > Player.maxammo_detpack)
			{
				Player.ammo_detpack = Player.maxammo_detpack;
			}
			if (Goal.invincible_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 1048576;
				Player.invincible_time = TF_FLARE_OFF;
				Player.invincible_finished = time + Goal.invincible_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 32;
					Player.invincible_finished = time + 666;
				}
			}
			if (Goal.invisible_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 524288;
				Player.invisible_time = TF_FLARE_OFF;
				Player.invisible_finished = time + Goal.invisible_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 64;
					Player.invisible_finished = time + 666;
				}
			}
			if (Goal.super_damage_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 4194304;
				Player.super_time = TF_FLARE_OFF;
				Player.super_damage_finished = time + Goal.super_damage_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 128;
					Player.super_damage_finished = time + 666;
				}
			}
			if (Goal.radsuit_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 2097152;
				Player.rad_time = TF_FLARE_OFF;
				Player.radsuit_finished = time + Goal.radsuit_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 256;
					Player.radsuit_finished = time + 666;
				}
			}
		}
		Player.lives = Player.lives + Goal.lives;
		Player.real_frags = Player.real_frags + Goal.frags;
		if (!(toggleflags & 128))
		{
			Player.frags = Player.real_frags;
		}
		
		oldself = self;
		self = Player;
		TeamFortress_CheckClassStats();
		W_SetCurrentAmmo();	
		self = oldself;
	}
	if (Player.playerclass == 8 && (Goal.goal_result & 16))
	{
		self.immune_to_check = time + 4;
		Spy_RemoveDisguise(Player);
	}
	if (Goal.items != TF_FLARE_LIT && Goal.classname != "item_tfgoal")
	{
		te = Finditem(Goal.items);
		if (te)
		{
			tfgoalitem_GiveToPlayer(te, Player, Goal);
		}
	}
	if (Goal.axhitme != TF_FLARE_LIT)
	{
		te = Finditem(Goal.axhitme);
		if (te.owner == Player)
		{
			tfgoalitem_RemoveFromPlayer(te, Player, TF_FLARE_OFF);
		}
	}
	if (Goal.remove_item_group != TF_FLARE_LIT)
	{
		te = find(world, classname, "item_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.remove_item_group && te.owner == AP)
			{
				oldte = te;
				te = find(te, classname, "item_tfgoal");
				tfgoalitem_RemoveFromPlayer(oldte, Player, TF_FLARE_OFF);
			}
			else
			{
				te = find(te, classname, "item_tfgoal");
			}
		}
	}
	if (Goal.display_item_status1 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status1);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Goal.display_item_status2 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status2);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Goal.display_item_status3 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status3);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Goal.display_item_status4 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status4);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Player.autodiscard)
	{
		oldself = self;
		self = Player;
		TeamFortress_Discard ();
		self = oldself;
	}
};

void(entity Goal, entity Player) RemoveResults = 
{
	local entity oldself;
	local entity te;
	local float puinvin;
	local float puinvis;
	local float puquad;
	local float purad;
	if (Goal.classname == "item_tfgoal")
	{
		if (!(Player.item_list & Goal.item_list))
		{
			return;
		}
		if (Goal.goal_activation & 1024)
		{
			return;
		}
		Player.item_list = Player.item_list - (Player.item_list & Goal.item_list);
	}
	if (Goal.health > TF_FLARE_LIT)
	{
		TF_T_Damage(Player, Goal, Goal, Goal.health, TF_FLARE_OFF, TF_FLARE_LIT);
	}
	if (Goal.health < TF_FLARE_LIT)
	{
		T_Heal(Player, TF_FLARE_LIT - Goal.health, TF_FLARE_LIT);
	}
	Player.lives = Player.lives - Goal.lives;
	Player.armortype = Player.armortype - Goal.armortype;
	Player.armorvalue = Player.armorvalue - Goal.armorvalue;
	Player.armorclass = Player.armorclass - (Player.armorclass & Goal.armorclass);
	Player.real_frags = Player.real_frags - Goal.frags;
	if (!(toggleflags & 128))
	{
		Player.frags = Player.real_frags;
	}
	Player.ammo_shells = Player.ammo_shells - Goal.ammo_shells;
	Player.ammo_nails = Player.ammo_nails - Goal.ammo_nails;
	Player.ammo_rockets = Player.ammo_rockets - Goal.ammo_rockets;
	Player.ammo_cells = Player.ammo_cells - Goal.ammo_cells;
	Player.ammo_medikit = Player.ammo_medikit - Goal.ammo_medikit;
	Player.ammo_detpack = Player.ammo_detpack - Goal.ammo_detpack;
	Player.no_grenades_1 = Player.no_grenades_1 - Goal.no_grenades_1;
	Player.no_grenades_2 = Player.no_grenades_2 - Goal.no_grenades_2;
	puinvin = TF_FLARE_LIT;
	puinvis = TF_FLARE_LIT;
	puquad = TF_FLARE_LIT;
	purad = TF_FLARE_LIT;
	te = find(world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == Player && te != Goal)
		{
			if (te.invincible_finished > TF_FLARE_LIT)
			{
				puinvin = TF_FLARE_OFF;
			}
			if (te.invisible_finished > TF_FLARE_LIT)
			{
				puinvis = TF_FLARE_OFF;
			}
			if (te.super_damage_finished > TF_FLARE_LIT)
			{
				puquad = TF_FLARE_OFF;
			}
			if (te.radsuit_finished > TF_FLARE_LIT)
			{
				purad = TF_FLARE_OFF;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (Goal.invincible_finished > TF_FLARE_LIT && !puinvin)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 32);
		Player.items = Player.items | 1048576;
		Player.invincible_time = TF_FLARE_OFF;
		Player.invincible_finished = time + Goal.invincible_finished;
	}
	if (Goal.invisible_finished > TF_FLARE_LIT && !puinvis)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 64);
		Player.items = Player.items | 524288;
		Player.invisible_time = TF_FLARE_OFF;
		Player.invisible_finished = time + Goal.invisible_finished;
	}
	if (Goal.super_damage_finished > TF_FLARE_LIT && !puquad)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 128);
		Player.items = Player.items | 4194304;
		Player.super_time = TF_FLARE_OFF;
		Player.super_damage_finished = time + Goal.super_damage_finished;
	}
	if (Goal.radsuit_finished > TF_FLARE_LIT && !purad)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 256);
		Player.items = Player.items | 2097152;
		Player.rad_time = TF_FLARE_OFF;
		Player.radsuit_finished = time + Goal.radsuit_finished;
	}
	oldself = self;
	self = Player;
	TeamFortress_CheckClassStats();
	W_SetCurrentAmmo();
	self = oldself;
};

float(entity Goal, entity AP) APMeetsCriteria = 
{
	local float gotone;
	local entity te;
	if (AP != world)
	{
		if (Goal.team_no)
		{
			if (Goal.team_no != AP.team_no)
			{
				return TF_FLARE_LIT;
			}
		}
		if (Goal.playerclass)
		{
			if (Goal.playerclass != AP.playerclass)
			{
				return TF_FLARE_LIT;
			}
		}
		if (Goal.items_allowed)
		{
			te = Finditem(Goal.items_allowed);
			if (te.owner != AP)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	if (Goal.if_goal_is_active)
	{
		te = Findgoal(Goal.if_goal_is_active);
		if (te.goal_state != TF_FLARE_OFF)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.if_goal_is_inactive)
	{
		te = Findgoal(Goal.if_goal_is_inactive);
		if (te.goal_state != 2)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.if_goal_is_removed)
	{
		te = Findgoal(Goal.if_goal_is_removed);
		if (te.goal_state != 3)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.if_group_is_active)
	{
		te = find(world, classname, "info_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.if_group_is_active)
			{
				if (te.goal_state != TF_FLARE_OFF)
				{
					return TF_FLARE_LIT;
				}
			}
			te = find(te, classname, "info_tfgoal");
		}
	}
	if (Goal.if_group_is_inactive)
	{
		te = find(world, classname, "info_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.if_group_is_inactive)
			{
				if (te.goal_state != 2)
				{
					return TF_FLARE_LIT;
				}
			}
			te = find(te, classname, "info_tfgoal");
		}
	}
	if (Goal.if_group_is_removed)
	{
		te = find(world, classname, "info_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.if_group_is_removed)
			{
				if (te.goal_state != 3)
				{
					return TF_FLARE_LIT;
				}
			}
			te = find(te, classname, "info_tfgoal");
		}
	}
	if (Goal.if_item_has_moved)
	{
		te = Finditem(Goal.if_item_has_moved);
		if (te)
		{
			if (te.goal_state != TF_FLARE_OFF && te.origin == te.oldorigin)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	if (Goal.if_item_hasnt_moved)
	{
		te = Finditem(Goal.if_item_hasnt_moved);
		if (te)
		{
			if (te.goal_state == TF_FLARE_OFF || te.origin != te.oldorigin)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	if (AP != world)
	{
		gotone = TF_FLARE_LIT;
		if (Goal.has_item_from_group)
		{
			te = find(world, classname, "item_tfgoal");
			while (te != world && !gotone)
			{
				if (te.group_no == Goal.has_item_from_group && te.owner == AP)
				{
					gotone = TF_FLARE_OFF;
				}
				te = find(te, classname, "item_tfgoal");
			}
			if (!gotone)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	return TF_FLARE_OFF;
};

void(entity Goal) SetupRespawn = 
{
	if (Goal.search_time != TF_FLARE_LIT)
	{
		InactivateGoal(Goal);
		Goal.think = tfgoal_timer_tick;
		Goal.nextthink = time + Goal.search_time;
		return;
	}
	if (Goal.goal_result & TF_FLARE_OFF)
	{
		RemoveGoal(Goal);
		return;
	}
	if (Goal.wait > TF_FLARE_LIT)
	{
		Goal.nextthink = time + Goal.wait;
		Goal.think = DoRespawn;
		return;
	}
	else
	{
		if (Goal.wait == -1)
		{
			return;
		}
	}
	InactivateGoal(Goal);
};

void() DoRespawn = 
{
	RestoreGoal(self);
	InactivateGoal(self);
};

float(entity Goal, entity AP) Activated = 
{
	local float APMet;
	local float RevAct;
	local float Act;
	if (Goal.goal_state == TF_FLARE_OFF)
	{
		return TF_FLARE_LIT;
	}
	if (Goal.goal_state == 3)
	{
		return TF_FLARE_LIT;
	}
	if (Goal.goal_state == 4)
	{
		return TF_FLARE_LIT;
	}
	APMet = APMeetsCriteria(Goal, AP);
	if (Goal.classname == "item_tfgoal")
	{
		RevAct = Goal.goal_activation & 64;
	}
	else
	{
		RevAct = Goal.goal_activation & 4;
	}
	Act = TF_FLARE_LIT;
	if (APMet)
	{
		if (!RevAct)
		{
			Act = TF_FLARE_OFF;
		}
	}
	else
	{
		if (RevAct)
		{
			Act = TF_FLARE_OFF;
		}
	}
	return Act;
};

void(entity Goal, entity AP, entity ActivatingGoal) AttemptToActivate = 
{
	local entity te;
	if (Activated(Goal, AP))
	{
		if (ActivatingGoal == Goal)
		{
			DoResults(Goal, AP, TF_FLARE_OFF);
		}
		else
		{
			if (ActivatingGoal != world)
			{
				DoResults(Goal, AP, ActivatingGoal.goal_result & 2);
			}
			else
			{
				DoResults(Goal, AP, TF_FLARE_LIT);
			}
		}
	}
	else
	{
		if (Goal.else_goal != TF_FLARE_LIT)
		{
			te = Findgoal(Goal.else_goal);
			if (te)
			{
				AttemptToActivate(te, AP, ActivatingGoal);
			}
		}
	}
};

void(entity Goal, entity AP) DoGoalWork = 
{
	local entity te;
	local entity RI;
	if (Goal.activate_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.activate_goal_no);
		if (te)
		{
			AttemptToActivate(te, AP, Goal);
		}
	}
	if (Goal.inactivate_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.inactivate_goal_no);
		if (te)
		{
			InactivateGoal(te);
		}
	}
	if (Goal.restore_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.restore_goal_no);
		if (te)
		{
			RestoreGoal(te);
		}
	}
	if (Goal.remove_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.remove_goal_no);
		if (te)
		{
			RemoveGoal(te);
		}
	}
	if (Goal.return_item_no != TF_FLARE_LIT)
	{
		te = Finditem(Goal.return_item_no);
		if (te)
		{
			if (te.goal_state == TF_FLARE_OFF)
			{
				tfgoalitem_RemoveFromPlayer(te, te.owner, TF_FLARE_OFF);
			}
			RI = spawn();
			RI.enemy = te;
			RI.think = ReturnItem;
			RI.nextthink = time + 0.1;
			te.solid = TF_FLARE_LIT;
		}
	}
	if (Goal.remove_spawnpoint != TF_FLARE_LIT)
	{
		te = Findteamspawn(Goal.remove_spawnpoint);
		if (te)
		{
			te.goal_state = 3;
			te.team_str_home = string_null;
		}
	}
	if (Goal.restore_spawnpoint != TF_FLARE_LIT)
	{
		te = Findteamspawn(Goal.restore_spawnpoint);
		if (te)
		{
			if (te.goal_state == 3)
			{
				te.goal_state = 2;
				if (te.team_no == TF_FLARE_OFF)
				{
					te.team_str_home = "ts1";
				}
				else
				{
					if (te.team_no == 2)
					{
						te.team_str_home = "ts2";
					}
					else
					{
						if (te.team_no == 3)
						{
							te.team_str_home = "ts3";
						}
						else
						{
							if (te.team_no == 4)
							{
								te.team_str_home = "ts4";
							}
						}
					}
				}
			}
		}
	}
};

void(entity Goal, entity AP) DoGroupWork = 
{
	local string st;
	local entity tg;
	local float allset;
	if (Goal.all_active != TF_FLARE_LIT)
	{
		if (Goal.last_impulse == TF_FLARE_LIT)
		{
			dprint("Goal ");
			st = ftos(Goal.goal_no);
			dprint(st);
			dprint(" has a .all_active specified, but no .last_impulse\n");
		}
		else
		{
			allset = TF_FLARE_OFF;
			tg = find(world, classname, "info_tfgoal");
			while (tg)
			{
				if (tg.group_no == Goal.all_active)
				{
					if (tg.goal_state != TF_FLARE_OFF)
					{
						allset = TF_FLARE_LIT;
					}
				}
				tg = find(tg, classname, "info_tfgoal");
			}
			if (allset)
			{
				tg = Findgoal(Goal.last_impulse);
				if (tg)
				{
					DoResults(tg, AP, Goal.goal_result & 2);
				}
			}
		}
	}
	if (Goal.activate_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.activate_group_no)
			{
				DoResults(tg, AP, TF_FLARE_LIT);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.inactivate_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.inactivate_group_no)
			{
				InactivateGoal(tg);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.remove_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.remove_group_no)
			{
				RemoveGoal(tg);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.restore_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.restore_group_no)
			{
				RestoreGoal(tg);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.remove_spawngroup != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_player_teamspawn");
		while (tg)
		{
			if (tg.group_no == Goal.remove_spawngroup)
			{
				tg.goal_state = 3;
				tg.team_str_home = string_null;
			}
			tg = find(tg, classname, "info_player_teamspawn");
		}
	}
	if (Goal.restore_spawngroup != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_player_teamspawn");
		while (tg)
		{
			if (tg.group_no == Goal.restore_spawngroup)
			{
				tg.goal_state = 2;
				if (tg.team_no == TF_FLARE_OFF)
				{
					tg.team_str_home = "ts1";
				}
				else
				{
					if (tg.team_no == 2)
					{
						tg.team_str_home = "ts2";
					}
					else
					{
						if (tg.team_no == 3)
						{
							tg.team_str_home = "ts3";
						}
						else
						{
							if (tg.team_no == 4)
							{
								tg.team_str_home = "ts4";
							}
						}
					}
				}
			}
			tg = find(tg, classname, "info_player_teamspawn");
		}
	}
};

void(entity Item, entity AP) DoItemGroupWork = 
{
	local entity tg;
	local entity carrier;
	local float allcarried;
	local string st;
	allcarried = TF_FLARE_OFF;
	if (Item.distance != TF_FLARE_LIT)
	{
		if (Item.pain_finished == TF_FLARE_LIT)
		{
			dprint("GoalItem ");
			st = ftos(Item.goal_no);
			dprint(st);
			dprint(" has a .distance specified, but no .pain_finished\n");
		}
		tg = find(world, classname, "item_tfgoal");
		while (tg)
		{
			if (tg.group_no == Item.distance)
			{
				if (tg.goal_state != TF_FLARE_OFF)
				{
					allcarried = TF_FLARE_LIT;
				}
			}
			tg = find(tg, classname, "item_tfgoal");
		}
		if (allcarried == TF_FLARE_OFF)
		{
			tg = Findgoal(Item.pain_finished);
			if (tg)
			{
				DoResults(tg, AP, Item.goal_result & 2);
			}
		}
	}
	allcarried = TF_FLARE_OFF;
	if (Item.speed != TF_FLARE_LIT)
	{
		if (Item.attack_finished == TF_FLARE_LIT)
		{
			dprint("GoalItem ");
			st = ftos(Item.goal_no);
			dprint(st);
			dprint(" has a .speed specified, but no .attack_finished\n");
		}
		carrier = world;
		tg = find(world, classname, "item_tfgoal");
		while (tg)
		{
			if (tg.group_no == Item.speed)
			{
				if (tg.goal_state != TF_FLARE_OFF)
				{
					allcarried = TF_FLARE_LIT;
				}
				else
				{
					if (carrier == world)
					{
						carrier = tg.owner;
					}
					else
					{
						if (carrier != tg.owner)
						{
							allcarried = TF_FLARE_LIT;
						}
					}
				}
			}
			tg = find(tg, classname, "item_tfgoal");
		}
		if (allcarried == TF_FLARE_OFF)
		{
			tg = Findgoal(Item.attack_finished);
			if (tg)
			{
				DoResults(tg, AP, Item.goal_result & 2);
			}
		}
	}
};

void(entity Goal, entity AP) DoTriggerWork = 
{
	local entity t;
	if (Goal.killtarget)
	{
		t = world;
		do
		{
			t = find(t, targetname, Goal.killtarget);
			if (t != world)
			{
				remove(t);
			}
		} while (t != world);
	}
	if (Goal.target)
	{
		t = world;
		activator = AP;
		do
		{
			t = find(t, targetname, Goal.target);
			if (t == world)
			{
				return;
			}
			stemp = self;
			otemp = other;
			self = t;
			other = stemp;
			if (self.use != SUB_Null)
			{
				if (self.use)
				{
					self.use();
				}
			}
			self = stemp;
			other = otemp;
			activator = AP;
		} while (t != world);
	}
};

void() DelayedResult = 
{
	if (self.enemy.goal_state == 4)
	{
		DoResults(self.enemy, self.owner, self.weapon);
	}
	dremove(self);
};

void(entity Goal, entity AP, float addb) DoResults = 
{
	local entity te;
	local float winners;

	if (Goal.goal_state == TF_FLARE_OFF)
	{
		return;
	}
	if (Goal.delay_time > TF_FLARE_LIT && Goal.goal_state != 4)
	{
		Goal.goal_state = 4;
		te = spawn();
		te.think = DelayedResult;
		te.nextthink = time + Goal.delay_time;
		te.owner = AP;
		te.enemy = Goal;
		te.weapon = addb;
		return;
	}
	UpdateAbbreviations(Goal);
	Goal.goal_state = 2;
	if (Goal.noise)
	{
		if (Goal.volume == TF_FLARE_OFF)
		{
			sound(other, 3, Goal.noise, TF_FLARE_OFF, TF_FLARE_LIT);
		}
		else
		{
			sound(other, 3, Goal.noise, TF_FLARE_OFF, TF_FLARE_OFF);
		}
	}
	winners = TF_FLARE_LIT;
	if (Goal.increase_team1 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(TF_FLARE_OFF, Goal.increase_team1);
		winners = TF_FLARE_OFF;
	}
	if (Goal.increase_team2 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(2, Goal.increase_team2);
		winners = TF_FLARE_OFF;
	}
	if (Goal.increase_team3 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(3, Goal.increase_team3);
		winners = TF_FLARE_OFF;
	}
	if (Goal.increase_team4 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(4, Goal.increase_team4);
		winners = TF_FLARE_OFF;
	}
	if (winners == TF_FLARE_OFF)
	{
		TeamFortress_TeamShowScores(2);
	}
	te = find(world, classname, "player");
	while (te != world)
	{
		if (Goal.broadcast != string_null && CTF_Map == TF_FLARE_LIT)
		{
			CenterPrint2(te, "\n\n\n", Goal.broadcast);
		}
		if (Goal.netname_broadcast != string_null && CTF_Map == TF_FLARE_LIT)
		{
			sprint(te, 2, AP.netname);
			sprint(te, 2, Goal.netname_broadcast);
		}
		if (AP == te)
		{
			if (Goal.message != string_null)
			{
				CenterPrint2(te, Goal.message, AP.netname);
			}
		}
		else
		{
			if (AP.team_no == te.team_no)
			{
				if (Goal.owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					CenterPrint2(te, Goal.owners_team_broadcast, AP.netname);
				}
				else
				{
					if (Goal.team_broadcast != string_null)
					{
						CenterPrint2(te, Goal.team_broadcast, AP.netname);
					}
				}
				if (Goal.netname_owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Goal.netname_owners_team_broadcast);
				}
				else
				{
					if (Goal.netname_team_broadcast != string_null)
					{
						sprint(te, 2, AP.netname);
						sprint(te, 2, Goal.netname_team_broadcast);
					}
				}
			}
			else
			{
				if (Goal.owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					CenterPrint2(te, Goal.owners_team_broadcast, AP.netname);
				}
				else
				{
					if (Goal.non_team_broadcast != string_null)
					{
						CenterPrint2(te, Goal.non_team_broadcast, AP.netname);
					}
				}
				if (Goal.netname_owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Goal.netname_owners_team_broadcast);
				}
				else
				{
					if (Goal.netname_non_team_broadcast != string_null)
					{
						sprint(te, 2, AP.netname);
						sprint(te, 2, Goal.netname_non_team_broadcast);
					}
				}
			}
		}
		if (IsAffectedBy(Goal, te, AP))
		{
			if (Goal.search_time != TF_FLARE_LIT && (Goal.goal_effects & 64))
			{
				if (APMeetsCriteria(Goal, te))
				{
					Apply_Results(Goal, te, AP, addb);
				}
			}
			else
			{
				Apply_Results(Goal, te, AP, addb);
			}
		}
		te = find(te, classname, "player");
	}
	if (Goal.classname != "item_tfgoal")
	{
		Goal.goal_state = TF_FLARE_OFF;
	}
	if (Goal.goal_result & 4)
	{
		TeamFortress_TeamShowScores(TF_FLARE_OFF);
		winners = TeamFortress_TeamGetWinner();
		te = find(world, classname, "player");
		while (te)
		{
			te.takedamage = TF_FLARE_LIT;
			te.movetype = TF_FLARE_LIT;
			te.velocity = '0 0 0';
			te.avelocity = '0 0 0';
			te = find(te, classname, "player");
		}
		te = spawn();
		te.nextthink = time + 5;
		te.think = execute_changelevel;
		dremove(Goal);
		return;
	}

	DoGroupWork(Goal, AP);
	DoGoalWork(Goal, AP);
	DoTriggerWork(Goal, AP);
	if (Goal.classname == "info_tfgoal")
	{
		SetupRespawn(Goal);
	}
};

void() tfgoal_touch = 
{
	if (!(self.goal_activation & TF_FLARE_OFF))
	{
		return;
	}
	if (other.classname != "player")
	{
		return;
	}
	if (self.goal_state == TF_FLARE_OFF)
	{
		return;
	}
	AttemptToActivate(self, other, self);
};

void() info_tfgoal_use = 
{
	AttemptToActivate(self, activator, self);
};

void() tfgoal_timer_tick = 
{
	if (self.goal_state != 3)
	{
		if (APMeetsCriteria(self, world))
		{
			DoResults(self, world, TF_FLARE_OFF);
		}
		else
		{
			InactivateGoal(self);
			self.think = tfgoal_timer_tick;
			self.nextthink = time + self.search_time;
		}
	}
};

void() item_tfgoal_touch = 
{
	local entity te;
	if (other.classname != "player")
	{
		return;
	}
	if (other.health <= TF_FLARE_LIT)
	{
		return;
	}
	if (other.is_feigning)	// TF 2.9'd!
		return;
	// for flag dropping
	if ( (self.tent == other) && (time < self.option5) )
	{
		return;
	}
	if (Activated(self, other))
	{
		tfgoalitem_GiveToPlayer(self, other, self);
		self.goal_state = TF_FLARE_OFF;
	}
	else
	{
		if (self.else_goal != TF_FLARE_LIT)
		{
			te = Findgoal(self.else_goal);
			if (te)
			{
				AttemptToActivate(te, other, self);
			}
		}
	}
};

void(entity Item, entity AP, entity Goal) tfgoalitem_GiveToPlayer = 
{
	Item.owner = AP;
	if (Item.mdl != string_null)
	{
		setmodel(Item, string_null);
	}
	Item.solid = TF_FLARE_LIT;
	if (Item.goal_activation & TF_FLARE_OFF)
	{
		AP.effects = AP.effects | 8;
	}
	if (Item.goal_activation & 2)
	{
		TeamFortress_SetSpeed(AP);
	}
	if (Item.goal_activation & 512)
	{
		Item.effects = Item.effects - (Item.effects | 8);
	}
	if (Item.items & 131072)
	{
		AP.items = AP.items | 131072;
		AP.effects = AP.effects | 64;
		newmis = spawn();
		newmis.owner = AP;
		newmis.movetype = 4;
		newmis.solid = TF_FLARE_LIT;
		setsize(newmis, '0 0 0', '0 0 0');
		newmis.angles = AP.angles;
		newmis.nextthink = time + 0.5;
		newmis.think = MoveFlag;
		newmis.skin = TF_FLARE_OFF;
		setmodel(newmis, "progs/tf_flag.mdl");
		setorigin(newmis, AP.origin);
	}
	if (Item.items & 262144)
	{
		AP.items = AP.items | 262144;
		AP.effects = AP.effects | 128;
		newmis = spawn();
		newmis.owner = AP;
		newmis.movetype = 4;
		newmis.solid = TF_FLARE_LIT;
		setsize(newmis, '0 0 0', '0 0 0');
		newmis.angles = AP.angles;
		newmis.nextthink = time + 0.5;
		newmis.think = MoveFlag;
		newmis.skin = 2;
		setmodel(newmis, "progs/tf_flag.mdl");
		setorigin(newmis, AP.origin);
	}
	if (Goal != Item)
	{
		if (Goal.goal_result & 8)
		{
			Item.goal_state = TF_FLARE_OFF;
			return;
		}
	}
	if (AP.playerclass == 8 && (Item.goal_result & 16))
	{
		AP.is_unabletospy = TF_FLARE_OFF;
	}
	DoResults(Item, AP, TF_FLARE_OFF);
	DoItemGroupWork(Item, AP);
};

void() ReturnItem = 
{
	self.enemy.goal_state = 2;
	self.enemy.solid = TF_FLARE_OFF;
	self.enemy.movetype = TF_FLARE_LIT;
	self.enemy.touch = item_tfgoal_touch;
	self.enemy.origin = self.enemy.oldorigin;
	if (self.enemy.mdl != string_null)
	{
		setmodel(self.enemy, self.enemy.mdl);
	}
	setorigin(self.enemy, self.enemy.origin);
	sound(self.enemy, 2, "items/itembk2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	tfgoalitem_checkgoalreturn(self.enemy);
	dremove(self);
};

#ifdef clan_progs
void (entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer =
{
    local entity te;
    local float lighton;
    local float slowon;
    local float key1on;
    local float key2on;
    local float spyoff;
    local entity DelayReturn;

    if (Item == world) {
	objerror ("error: tfgoalitem_RemoveFromPlayer(): Item == world");
	return;
    }
    lighton = 0;
    slowon = 0;
    key1on = 0;
    key2on = 0;
    spyoff = 0;

    te = find (world, classname, "item_tfgoal");
    while (te) {
	if ((te.owner == AP) && (te != Item)) {
	    if (te.goal_activation & 1)
		lighton = 1;

	    if (te.goal_activation & 2)
		slowon = 1;

	    if (te.items & 131072)
		key1on = 1;

	    if (te.items & 262144)
		key2on = 1;

	    if (te.goal_result & 16)
		spyoff = 1;
	}
	te = find (te, classname, "item_tfgoal");
    }
    if (!lighton) {
	if (AP.invincible_finished > (time + 3)) {
	    lighton = 1;
	} else if (AP.super_damage_finished > (time + 3)) {
	    lighton = 1;
	}
    }
    if (!lighton) {
	AP.effects = AP.effects - (AP.effects & 8);
	AP.effects = AP.effects - (AP.effects & 64);
	AP.effects = AP.effects - (AP.effects & 128);
    }
    if (Item.goal_activation & 512)
	Item.effects = Item.effects | 8;

    if (!spyoff)
	AP.is_unabletospy = 0;

    if (!key1on)
	AP.items = AP.items - (AP.items & 131072);

    if (!key2on)
	AP.items = AP.items - (AP.items & 262144);

    te = find (world, classname, "player");
    while (te != world) {
	if (IsAffectedBy (Item, te, AP))
	    RemoveResults (Item, te);
	te = find (te, classname, "player");
    }
    if ((method == 0) || (method == 2)) {
	te = find (world, classname, "player");
	while (te != world) {
	    if (te.team_no == Item.owned_by) {
		if (Item.team_drop != string_null)
		    CenterPrint2 (te, "\n\n\n", Item.team_drop);

		if (Item.netname_team_drop != string_null) {
		    sprint (te, 2, AP.netname, Item.netname_team_drop);
		}
	    } else {
		if (Item.non_team_drop != string_null)
		    CenterPrint2 (te, "\n\n\n", Item.non_team_drop);

		if (Item.netname_non_team_drop != string_null) {
		    sprint (te, 2, AP.netname, Item.netname_non_team_drop);
		}
	    }
	    te = find (te, classname, "player");
	}
	if (Item.goal_activation & 8) {
	    DelayReturn = spawn ();
	    DelayReturn.enemy = Item;
	    if (method == 0) {
		DelayReturn.weapon = 0;
	    } else {
		DelayReturn.weapon = 1;
	    }
	    DelayReturn.think = ReturnItem;
	    DelayReturn.nextthink = time + 0.5;
	} else {
	    if (Item.goal_activation & 4) {
		if ((method == 2) /*&& (Item.goal_activation & 4096)*/) {
		    tfgoalitem_drop (Item, 1, AP);
		} else {
		    tfgoalitem_drop (Item, 0, AP);
		}
	    } else {
		Item.owner = world;
		dremove (Item);
		TeamFortress_SetSpeed (AP);
		return;
	    }
	}
	Item.owner = world;
	Item.flags = Item.flags - (Item.flags & 512);
//	setsize (Item, Item.goal_min, Item.goal_max);
		setsize(Item, '-16 -16 0', '16 16 56');	// mtf size
	TeamFortress_SetSpeed (AP);
	return;
    } else {
	if (method == 1) {
	    if (Item.goal_activation & 16) {
		DelayReturn = spawn ();
		DelayReturn.enemy = Item;
		DelayReturn.weapon = 2;
		DelayReturn.think = ReturnItem;
		DelayReturn.nextthink = time + 0.5;
		Item.owner = world;
		TeamFortress_SetSpeed (AP);
		return;
	    }
	    Item.solid = 0;
	    Item.owner = world;
	    TeamFortress_SetSpeed (AP);
	    return;
	}
    }
    objerror ("Invalid method passed into tfgoalitem_RemoveFromPlayer\n");
};
#else
void(entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer = 
{
	local entity te;
	local float lighton;
	local float slowon;
	local float key1on;
	local float key2on;
	local float spyoff;
	local entity DelayReturn;
	if (Item == world)
	{
		dprint("error: tfgoalitem_RemoveFromPlayer(): Item == world");
		return;
	}
	lighton = TF_FLARE_LIT;
	slowon = TF_FLARE_LIT;
	key1on = TF_FLARE_LIT;
	key2on = TF_FLARE_LIT;
	spyoff = TF_FLARE_LIT;
	te = find(world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == AP && te != Item)
		{
			if (te.goal_activation & TF_FLARE_OFF)
			{
				lighton = TF_FLARE_OFF;
			}
			if (te.goal_activation & 2)
			{
				slowon = TF_FLARE_OFF;
			}
			if (te.items & 131072)
			{
				key1on = TF_FLARE_OFF;
			}
			if (te.items & 262144)
			{
				key2on = TF_FLARE_OFF;
			}
			if (te.goal_result & 16)
			{
				spyoff = TF_FLARE_OFF;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (!lighton)
	{
		if (AP.invincible_finished > time + 3)
		{
			lighton = TF_FLARE_OFF;
		}
	}
	if (!lighton)
	{
		AP.effects = AP.effects - (AP.effects & 8);
	}
	if (Item.goal_activation & 512)
	{
		Item.effects = Item.effects | 8;
	}
	if (!spyoff)
	{
		AP.is_unabletospy = TF_FLARE_LIT;
	}
	if (!key1on)
	{
		AP.items = AP.items - (AP.items & 131072);
	}
	if (!key2on)
	{
		AP.items = AP.items - (AP.items & 262144);
	}
	te = find(world, classname, "player");
	while (te != world)
	{
		if (IsAffectedBy(Item, te, AP))
		{
			RemoveResults(Item, te);
		}
		te = find(te, classname, "player");
	}
	if ((method == TF_FLARE_LIT) || (method == 2))
	{
		te = find(world, classname, "player");
		while (te != world)
		{
			if (te.team_no == Item.owned_by)
			{
				if (Item.team_drop != string_null)
				{
					CenterPrint2(te, "\n\n\n", Item.team_drop);
				}
				if (Item.netname_team_drop != string_null)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Item.netname_team_drop);
				}
			}
			else
			{
				if (Item.non_team_drop != string_null)
				{
					CenterPrint2(te, "\n\n\n", Item.non_team_drop);
				}
				if (Item.netname_non_team_drop != string_null)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Item.netname_non_team_drop);
				}
			}
			te = find(te, classname, "player");
		}
		if (Item.goal_activation & 8)
		{
			DelayReturn = spawn();
			DelayReturn.enemy = Item;
			DelayReturn.think = ReturnItem;
			DelayReturn.nextthink = time + 0.5;
		}
		else
		{
			if (Item.goal_activation & 4)
			{
				if (method == 0)
					tfgoalitem_drop(Item);
			}
			else
			{
				Item.owner = world;
				dremove(Item);
				TeamFortress_SetSpeed(AP);
				return;
			}
		}
		Item.owner = world;
		TeamFortress_SetSpeed(AP);
		return;
	}
	if (method == TF_FLARE_OFF)
	{
		if (Item.goal_activation & 16)
		{
			DelayReturn = spawn();
			DelayReturn.enemy = Item;
			DelayReturn.think = ReturnItem;
			DelayReturn.nextthink = time + 0.5;
			Item.owner = world;
			TeamFortress_SetSpeed(AP);
			return;
		}
		Item.solid = TF_FLARE_LIT;
		Item.owner = world;
		TeamFortress_SetSpeed(AP);
		return;
	}

	dprint("Invalid method passed into tfgoalitem_RemoveFromPlayer\n");
};
#endif

void() tfgoalitem_dropthink = 
{
	local float pos;
	if (self.userid == 1)
		self.movetype = 6;
	else
		self.movetype = 10; //6;
	
	if (self.pausetime != TF_FLARE_LIT)
	{
		pos = pointcontents(self.origin);
		if (pos == -4)
		{
			self.nextthink = time + self.pausetime / 4;
		}
		else
		{
			if (pos == -5)
			{
				self.nextthink = time + 5;
			}
			else
			{
				if (pos == -2 || pos == -6)
				{
					self.nextthink = time + 2;
				}
				else
				{
					self.nextthink = time + self.pausetime;
				}
			}
		}
		self.think = tfgoalitem_remove;
	}
};

#ifdef clan_progs
void () tfgoalitem_droptouch =
{
    self.touch = item_tfgoal_touch;
//    self.nextthink = time + 4.25;
    self.nextthink = time + .25;
    self.think = tfgoalitem_dropthink;
};
/*
void (entity Item, float PAlive, entity P) tfgoalitem_drop =
{
    Item.origin = Item.owner.origin;
    setorigin (Item, Item.origin);
    Item.camangle = Item.owner.origin - '0 0 8';
    Item.camdist = 0;
    Item.velocity_z = 400;
    Item.velocity_x = -50 + (random () * 100);
    Item.velocity_y = -50 + (random () * 100);
    Item.goal_state = 2;
    Item.movetype = 6;
    if (Item.goal_activation & 8192) {
	Item.solid = 2;
    } else {
	Item.solid = 1;
    }
    if (Item.mdl != string_null) {
	setmodel (Item, Item.mdl);
    }
    setsize (Item, Item.goal_min, Item.goal_max);
    Item.owner = P;
    if (PAlive == 1) {
	makevectors (P.v_angle);
	if (P.v_angle_x) {
	    Item.velocity = (v_forward * 400) + (v_up * 200);
	} else {
	    Item.velocity = aim (P, 10000);
	    Item.velocity = Item.velocity * 400;
	    Item.velocity_z = 200;
	}
	Item.touch = SUB_Null;
	Item.nextthink = time + 0.75;
	Item.think = tfgoalitem_droptouch;
    } else {
	Item.touch = item_tfgoal_touch;
	Item.nextthink = time + 5;
	Item.think = tfgoalitem_dropthink;
    }
};
*/

void (entity Item, float PAlive, entity P) tfgoalitem_drop =
{
    Item.origin = Item.owner.origin;
    setorigin (Item, Item.origin);
    Item.camangle = Item.owner.origin - '0 0 8';
    Item.camdist = 0;
    Item.velocity_z = 50;
    Item.velocity_x = -50 + (random () * 100);
    Item.velocity_y = -50 + (random () * 100);
    Item.goal_state = 2;
    Item.movetype = 6;
    if (Item.goal_activation & 8192) {
	Item.solid = 2;
    } else {
	Item.solid = 1;
    }
    if (Item.mdl != string_null) {
	setmodel (Item, Item.mdl);
    }
    //setsize (Item, Item.goal_min, Item.goal_max);
	setsize(Item, '-16 -16 0', '16 16 56');		// MTF size
    Item.owner = P;
    if (PAlive == 1) 
    {
		setsize(Item, '-16 -16 0', '16 16 56');
		makevectors (P.v_angle);
		if (P.v_angle_x) 
		{
		    Item.velocity = (v_forward * 400) + (v_up * 200);
		} 
		else 
		{
		    Item.velocity = aim (P, 10000);
		    Item.velocity = Item.velocity * 400;
		    Item.velocity_z = 200;
		}
		Item.userid = 1;
		Item.touch = SUB_Null;
		Item.nextthink = time + 0.25;
		Item.think = tfgoalitem_droptouch;
    } 
    else 
    {
		Item.touch = item_tfgoal_touch;
		Item.nextthink = time + 5;
		Item.think = tfgoalitem_dropthink;
    }
};
#else
void(entity Item) tfgoalitem_drop = 
{
	Item.origin = Item.owner.origin - '0 0 8';
	//Item.velocity_z = 400;
	//Item.velocity_x = -50 + random() * 100;
	//Item.velocity_y = -50 + random() * 100;
	Item.velocity_z = 1;
	Item.velocity_x = 0;
	Item.velocity_y = 0;
	Item.goal_state = 2;
	Item.movetype = 6;
	Item.solid = TF_FLARE_OFF;
	Item.touch = item_tfgoal_touch;
	setorigin(Item, Item.origin - '0 0 16');
	setsize(Item, '-16 -16 0', '16 16 56');
	if (Item.mdl != string_null)
	{
		setmodel(Item, Item.mdl);
	}
	Item.nextthink = time + 5;
	Item.think = tfgoalitem_dropthink;
};
#endif

void() tfgoalitem_remove = 
{
	local entity te;
	if (self.goal_state == TF_FLARE_OFF)
	{
		return;
	}
	if (self.goal_activation & 32)
	{
		self.solid = TF_FLARE_OFF;
		self.touch = item_tfgoal_touch;
		self.origin = self.oldorigin;
		if (self.mdl != string_null)
		{
			setmodel(self, self.mdl);
		}
		setorigin(self, self.origin);
		sound(self, 2, "items/itembk2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		tfgoalitem_checkgoalreturn(self);
		if (self.noise3 != string_null || self.noise4 != string_null)
		{
			te = find(world, classname, "player");
			while (te)
			{
				if (te.team_no == self.owned_by)
				{
					CenterPrint2(te, "\n\n\n", self.noise3);
				}
				else
				{
					CenterPrint2(te, "\n\n\n", self.noise4);
				}
				te = find(te, classname, "player");
			}
		}
		return;
	}
	dremove(self);
};

void(entity Item) tfgoalitem_checkgoalreturn = 
{
	local entity te;
	if (Item.impulse != TF_FLARE_LIT)
	{
		te = Findgoal(Item.impulse);
		if (te)
		{
			te = Findgoal(Item.impulse);
			if (te)
			{
				AttemptToActivate(te, world, Item);
			}
		}
	}
};

void(entity Goal, entity Player, entity Item) DisplayItemStatus = 
{
	if (Item.goal_state == TF_FLARE_OFF)
	{
		if (Player.team_no == Item.owned_by)
		{
			sprint(Player, 2, Goal.team_str_carried);
		}
		else
		{
			sprint(Player, 2, Goal.non_team_str_carried);
		}
		sprint(Player, 2, " ");
		if (Player == Item.owner)
		{
			sprint(Player, 2, " You");
		}
		else
		{
			sprint(Player, 2, Item.owner.netname);
		}
		sprint(Player, 2, ".");
	}
	else
	{
		if (Item.origin != Item.oldorigin)
		{
			if (Player.team_no == Item.owned_by)
			{
				sprint(Player, 2, Goal.team_str_moved);
			}
			else
			{
				sprint(Player, 2, Goal.non_team_str_moved);
			}
		}
		else
		{
			if (Player.team_no == Item.owned_by)
			{
				sprint(Player, 2, Goal.team_str_home);
			}
			else
			{
				sprint(Player, 2, Goal.non_team_str_home);
			}
		}
	}
	sprint(Player, 2, "\n");
};

void() info_player_team1 = 
{
	CTF_Map = TF_FLARE_OFF;
	self.classname = "info_player_teamspawn";
	self.team_no = 2;
	self.goal_effects = TF_FLARE_OFF;
	self.team_str_home = "ts2";
};

void() info_player_team2 = 
{
	CTF_Map = TF_FLARE_OFF;
	self.classname = "info_player_teamspawn";
	self.team_no = TF_FLARE_OFF;
	self.goal_effects = TF_FLARE_OFF;
	self.team_str_home = "ts1";
};

void() item_flag_team2 = 
{
	local entity dp;
	CTF_Map = TF_FLARE_OFF;
	precache_model("progs/w_s_key.mdl");
	precache_sound("ogre/ogwake.wav");
	precache_sound("boss2/pop2.wav");
	self.classname = "item_tfgoal";
	self.netname = "Team 1 Flag";
	self.broadcast = "  the enemy team's flag!\n";
	self.deathtype = "You've got the enemy flag!\n";
	self.noise = "ogre/ogwake.wav";
	self.mdl = "progs/tf_flag.mdl";
	self.skin = TF_FLARE_LIT;
	setmodel(self, self.mdl);
	self.goal_no = TF_FLARE_OFF;
	self.goal_activation = TF_FLARE_OFF | 4 | 128 | 32 | 16 | 512;
	self.goal_effects = TF_FLARE_OFF;
	self.pausetime = 128;
	setsize(self, '-16 -16 -24', '16 16 32');
	self.touch = item_tfgoal_touch;
	self.goal_state = 2;
	self.solid = TF_FLARE_OFF;
	setorigin(self, self.origin);
	self.nextthink = time + 0.2;
	self.think = TF_PlaceItem;
	dp = spawn();
	dp.origin = self.origin;
	dp.classname = "info_tfgoal";
	dp.goal_activation = TF_FLARE_OFF;
	dp.team_no = TF_FLARE_OFF;
	dp.items_allowed = 2;
	dp.goal_no = 3;
	dp.goal_effects = 3;
	dp.broadcast = "  the enemy flag!\n";
	dp.message = "You  the enemy flag!\n";
	dp.noise = "boss2/pop2.wav";
	dp.goal_result = 2;
	dp.activate_goal_no = 5;
	dp.axhitme = 2;
	dp.count = 10;
	dp.frags = 10;
	dp.solid = TF_FLARE_OFF;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
	dp = spawn();
	dp.origin = dp.origin;
	dp.classname = "info_tfgoal";
	dp.goal_effects = TF_FLARE_OFF;
	dp.frags = 5;
	dp.goal_activation = TF_FLARE_LIT;
	dp.goal_no = 5;
	dp.solid = TF_FLARE_LIT;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
};

void() item_flag_team1 = 
{
	local entity dp;
	CTF_Map = TF_FLARE_OFF;
	precache_model("progs/tf_flag.mdl");
	precache_sound("ogre/ogwake.wav");
	precache_sound("boss2/pop2.wav");
	self.classname = "item_tfgoal";
	self.netname = "Team 2 Flag";
	self.broadcast = "  the enemy team's flag!\n";
	self.deathtype = "You've got the enemy flag!\n";
	self.noise = "ogre/ogwake.wav";
	self.mdl = "progs/tf_flag.mdl";
	setmodel(self, self.mdl);
	self.skin = TF_FLARE_OFF;
	self.goal_no = 2;
	self.goal_activation = TF_FLARE_OFF | 4 | 128 | 32 | 16 | 512;
	self.goal_effects = TF_FLARE_OFF;
	self.pausetime = 128;
	setsize(self, '-16 -16 -24', '16 16 32');
	self.touch = item_tfgoal_touch;
	self.goal_state = 2;
	self.solid = TF_FLARE_OFF;
	setorigin(self, self.origin);
	self.nextthink = time + 0.2;
	self.think = TF_PlaceItem;
	dp = spawn();
	dp.origin = self.origin;
	dp.classname = "info_tfgoal";
	dp.goal_activation = TF_FLARE_OFF;
	dp.team_no = 2;
	dp.items_allowed = TF_FLARE_OFF;
	dp.goal_no = 4;
	dp.goal_effects = 3;
	dp.broadcast = "  the enemy flag!\n";
	dp.message = "You  the enemy flag!\n";
	dp.noise = "boss2/pop2.wav";
	dp.goal_result = 2;
	dp.activate_goal_no = 6;
	dp.axhitme = TF_FLARE_OFF;
	dp.count = 10;
	dp.frags = 10;
	dp.solid = TF_FLARE_OFF;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
	dp = spawn();
	dp.origin = dp.origin;
	dp.classname = "info_tfgoal";
	dp.goal_effects = TF_FLARE_OFF;
	dp.frags = 5;
	dp.goal_activation = TF_FLARE_LIT;
	dp.goal_no = 6;
	dp.solid = TF_FLARE_LIT;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
};

void() CTF_FlagCheck = 
{
	local entity te;
	local float flagcount;
	local float pos;
	flagcount = TF_FLARE_LIT;
	te = find(world, classname, "item_tfgoal");
	while (te != world)
	{
		if (te.goal_no == TF_FLARE_OFF)
		{
			pos = pointcontents(te.origin);
			if (pos == -2 || pos == -6)
			{
				dprint("*****BUG*****\nFlag(s) outside world.\nPlease report this.\n");
				te.nextthink = time + 0.2;
				te.think = tfgoalitem_remove;
			}
			flagcount = flagcount + TF_FLARE_OFF;
		}
		else
		{
			if (te.goal_no == 2)
			{
				pos = pointcontents(te.origin);
				if (pos == -2 || pos == -6)
				{
					dprint("*****BUG*****\nFlag(s) outside world.\nPlease report this.\n");
					te.nextthink = time + 0.2;
					te.think = tfgoalitem_remove;
				}
				flagcount = flagcount + TF_FLARE_OFF;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (flagcount != 2)
	{
		dprint("*****BUG*****\nFlag(s) missing.\nPlease report this.\n");
	}
	self.nextthink = time + 30;
};

#ifdef clan_progs
// tf 2.9 drop flag (throws)
void () DropGoalItems =
{
    local entity te;

    newmis = spawn ();
    makevectors (self.v_angle);
    v_forward = normalize (v_forward) * 64;
    newmis.origin = self.origin + v_forward;
    te = find (world, classname, "item_tfgoal");
    while (te) {
	if (te.owner == self)
	    if (te.goal_activation & 4096 || te.owner == self)
		tfgoalitem_RemoveFromPlayer (te, self, 2);
	
	te = find (te, classname, "item_tfgoal");
    }
    dremove (newmis);
};
#endif