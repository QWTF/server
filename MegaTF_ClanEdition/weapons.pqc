.float has_syringe, option, option5, is_squating;
.float last_used, tools, option4, vision, maxfbspeed;

// auto screenshot
//.float screenshot;
//

#ifdef clan_progs
void () DropGoalItems;
#endif

#ifdef tf29ents
void () DropGoalItems;
#endif

/* Used in MegaTF United.
// XTF stuff
float (float rangeDist, float typeFlag) AI_Target;
//
*/

// medic's self healing
void () HealSelf
//

//votemap_start
void (string put) votemap_start;

// HW spam lessener
.float hw_message_resttime;

float airscout, drop3, drop2, drop1;
void (float _p_10136) TeamFortress_ItemStatus;

float prematch;

void () lay;
void () unlay;

void () DropFlag;
void () Det_Disp;
void () Det_Sent;

void () review_timeleft;
void () TeamFortress_Timeleft;

void () TeamFortress_NightVision;
void () Prox_Disarm;
void () ProxiDie;
//entity (float head) MakeLink;
void() BallCheck;
void() TeamFortress_AmmoboxTouch;
void () TeamFortress_Spotlight;
// pablo. wra. frikqcc you pos. take that.
//
void() MushroomFlame;
void() DroneJet;
void(float tno) RemoveOldAmmobox;
string(float num) NumberToString1000;
float(float tno) num_team_ammoboxes;
void () W_FireBigAss;
void() BallTouch;
void() make_explosion;
void () DroneDie;
string(float pc) TeamFortress_GetClassName;
void(float tno) increment_team_ammoboxes;
void (vector org) spawn_tfog;
void () Drone;
void () Prox;
//void () endFlash;
void() button_fire;
void() ConcussionGrenadeTimer;
void() PipebombTouch;
//float (entity hwguy) hwguy_deflect;

void (entity targ, entity inflictor, entity attacker, float damage) T_Damage;
void (entity targ, entity inflictor, entity attacker, float damage, float T_flags, float T_AttackType) TF_T_Damage;
void () player_run;
void(entity bomb, entity attacker, float rad, entity ignore) T_RadiusDamage;
void() TeamFortress_DisplayDetectionItems;
float(vector veca, vector vecb) crossproduct;
void(vector org, float damage) SpawnBlood;
void(entity rhook) Reset_Grapple;
void() SuperDamageSound;
float() W_BestWeapon;
void() ConcussionGrenadeTimer;
void() W_PrintWeaponMessage;
void() button_touch;
void() button_fire;

// TeamFortress Impulse Commands
void() TeamFortress_ToggleGenderMessage;
void() TeamFortress_ChangeClass;
void() TeamFortress_DisplayLegalClasses;
void() TeamFortress_Inventory;
void() TeamFortress_SaveMe;
void() TeamFortress_ID;
void() TeamFortress_ShowTF;
void() TeamFortress_SniperWeapon;
void() TeamFortress_IncendiaryCannon;
void() TeamFortress_FlameThrower;
void() TeamFortress_PrimeGrenade;
void() TeamFortress_ThrowGrenade;
void() TeamFortress_Discard;
void(entity p) TeamFortress_SetSpeed;
void() TeamFortress_DetonatePipebombs;
void() PipebombTouch;
void() TeamFortress_DetpackStop;
void() SniperSight_Create;
void(float zoom_level) TF_zoom;
void() TeamFortress_ReloadCurrentWeapon;
void() TeamFortress_AutoZoomToggle;
void() TeamFortress_StatusQuery;
void() TeamFortress_SpyGoUndercover;
void (float _p_9330) TeamFortress_SpyFeignDeath;
void() TeamFortress_EngineerBuild;
//void() DropKey;
void() UseSpecialSkill;

// TeamFortress Pre-Impulse Commands
void(float scanrange) TeamFortress_Scan;
void(float timer) TeamFortress_SetDetpack;

// Team Functions
float(float tno) TeamFortress_TeamSet;
void(float tno) TeamFortress_TeamShowScores;
void(entity Player) TeamFortress_TeamShowMemberClasses;

// Camera Functions
void() CamLock;
void() CamDistLock;
void() CamVecLock;
void() CamAngleLock;
void() CamRevAngleLock;
void() CamProjectileLock;
void() CamProjectileZoom;
void() CamProjectileLockOn;
void() CamProjectileLockOff;
void() CamOffset;
void() CamDrop;
void() fadetoblack;
void() fadefromblack;
void() fadetowhite;
void() fadefromwhite;

// Engineer Functions
void(entity disp) Engineer_UseDispenser;
void(entity gun) Engineer_UseSentryGun;
//void(entity mortar) Engineer_UseMortar;

void(entity spy) Spy_RemoveDisguise;

// Help functions
void() TeamFortress_MOTD;
void() TeamFortress_HelpMap;
void(float res) StatusRes;

// BioInfection functions
void() BioInfection_Decay;
void() BioInfection_MonsterDecay;

// Attacking functions
void() W_FireFlame;
void() W_FireIncendiaryCannon;
void() W_FireTranq;
void () W_FireLaser;

// Timer Functions
void() HallucinationTimer;
void() TranquiliserTimer;

// CTF Support functions
void() TeamFortress_CTF_FlagInfo;

// #PC_UNDEFINED viewing functions
void() TF_MovePlayer;

void(vector org, float damage) SpawnBlood;

void() W_Precache =
{
	precache_sound("speech/yell/coverme.wav");
	precache_sound("speech/yell/overhere.wav");
	precache_sound("speech/yell/thisway.wav");
	precache_sound("speech/yell/followme.wav");
	precache_sound("speech/yell/incomng.wav");
	precache_sound("speech/yell/firehole.wav");
	precache_sound("speech/yell/gogogo.wav");
	precache_sound("speech/yell/lookout.wav");
	precache_sound("speech/yell/holdup.wav");
	precache_sound("speech/needlite.wav");
	precache_sound("effects/bodyhit1.wav");
	precache_sound("effects/bodyhit2.wav");
	precache_sound("zombie/z_miss.wav");
	precache_sound("weapons/drone.wav");
	precache_sound("weapons/knifedrw.wav");
	precache_sound("ambient/100hzhum.wav");
	precache_sound("weapons/jetjump.wav");
	precache_sound("enforcer/enfire.wav");
	precache_sound("shambler/smack.wav");
	precache_sound("weapons/r_exp3.wav");
	precache_sound("shambler/sboom.wav");
	precache_sound("weapons/sniper.wav");
	precache_sound("doors/ddoor2.wav");
	precache_sound("doors/airdoor2.wav");
	precache_sound("weapons/sgun1.wav");
	precache_sound("weapons/unreel.wav");
	precache_sound("weapons/retract.wav");
	precache_sound("weapons/rocklr1a.wav");
	precache_sound("weapons/railgr1a.wav");
	precache_sound("weapons/shotgr1a.wav");
	precache_sound("weapons/guncock.wav");
	precache_sound("weapons/ric1.wav");
	precache_sound("weapons/ric2.wav");
	precache_sound("weapons/ric3.wav");
	precache_sound("weapons/spike2.wav");
	precache_sound("weapons/tink1.wav");
	precache_sound("weapons/tink2.wav");
	precache_sound("weapons/shell2.wav");
	precache_sound("weapons/launch.wav");
	precache_sound("effects/mortar.wav");
	precache_sound("weapons/bounce.wav");
	precache_sound("weapons/shotgn2.wav");
	precache_sound("items/r_item1.wav");
	precache_sound("items/r_item2.wav");
	precache_sound("items/flare1.wav");
	precache_model("progs/s_expl.spr");
	precache_model("progs/beam.mdl");
	precache_model("progs/beam2.mdl");
	precache_model("progs/spikebal.mdl");
	precache_model("progs/flare.spr");
	precache_model("progs/lsrdrone.mdl");
	precache_model("progs/shell2.mdl");
	precache_model("progs/20mmcase.mdl");
	precache_model("progs/air-mirv.mdl");
	precache_model("progs/flame2.mdl");
	precache_model ("progs/syringe.mdl");
	precache_sound("ambience/fire1.wav");
	precache_model2("progs/v_spike.mdl");
	precache_sound("hknight/hit.wav");
	precache_sound("hknight/slash1.wav");
	precache_sound("doors/meduse.wav");
	precache_sound("weapons/tnkatck4.wav");
	precache_sound("weapons/pain.wav");
	precache_sound("weapons/gunidle1.wav");
	precache_sound("speech/excelent.wav");
	precache_sound("weapons/rifle.wav");
	precache_sound("weapons/plaser.wav");
	precache_sound("weapons/flmfire2.wav");
	precache_sound("misc/vapeur2.wav");
	precache_sound("weapons/chngnu1a.wav");
	precache_sound("weapons/asscan2.wav");
	precache_sound("weapons/chngnd1a.wav");
	precache_sound("weapons/dartgun.wav");
	precache_sound("weapons/lavapool.wav");
	precache_sound("misc/null.wav");
	precache_sound ("misc/secret.wav");
// XTF MDL
//	precache_model ("progs/xrail.mdl");
// END XTF MDL
// XTF SOUND
//	precache_sound ("weapons/railgun.wav");
// END XTF SOUND
	precache_sound ("misc/runekey.wav");
// 04 spycam and dropgrens
	if ((infokey (world, "dropgrens") == "on"))
	{
		precache_model2 ("progs/ammobox2.mdl");
	}
	if ((infokey (world, "spycam") == "on"))
	{
		precache_model2 ("progs/spycamb.mdl");
		precache_model2 ("progs/spycamc.mdl");
	}
// 11.11.04 sounds
	precache_sound ("misc/update.wav");
};

float() crandom =
{
	return 2 * (random() - 0.5);
};

void(float att_delay) Attack_Finished =
{
	if (self.tfstate & 32768)
	{
		self.attack_finished = time + att_delay * 3;
	}
	else
	{
		self.attack_finished = time + att_delay;
	}
};

void() ShellHit =
{
	if (self.skin == TF_FLARE_OFF)
	{
		sound(self, 3, "weapons/shell2.wav", 0.5, TF_FLARE_OFF);
	}
	else
	{
		if (random() < 0.5)
		{
			sound(self, 3, "weapons/tink1.wav", 0.5, TF_FLARE_OFF);
		}
		else
		{
			sound(self, 3, "weapons/tink2.wav", 0.6, TF_FLARE_OFF);
		}
	}
	return;
};

void () EjectShell =
{

	newmis = spawn ();
	newmis.movetype = 10;
	newmis.solid = 1;
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		if ((self.current_weapon == 32))
		{
			newmis.velocity = (((v_forward * 70) + (v_up * 90)) + ((random () * v_right) * -150));
		}
		else
		{
			newmis.velocity = (((v_forward * 70) + (v_up * 90)) + ((random () * v_right) * 150));
		}
	}
	else
	{
		newmis.velocity = aim (self, 10000);
		if ((self.current_weapon == 32))
		{
			newmis.velocity = ((newmis.velocity * 70) + ((random () * v_right) * -150));
		}
		else
		{
			newmis.velocity = ((newmis.velocity * 70) + ((random () * v_right) * 150));
		}
		newmis.velocity_z = (random () * 90);
	}
	if ((random () < 0.300000))
	{
		newmis.avelocity = '2000.000000 3000.000000 4000.000000';
	}
	else
	{
		if ((random () < 0.600000))
		{
			newmis.avelocity = '4000.000000 2000.000000 3000.000000';
		}
		else
		{
			newmis.avelocity = '7000.000000 5000.000000 1000.000000';
		}
	}
	setsize (newmis, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
	setorigin (newmis, ((self.origin + (v_forward * 10)) + '0.000000 0.000000 20.000000'));
	if ((self.playerclass == 6))
	{
		newmis.nextthink = (time + 1.500000);
		setmodel (newmis, "progs/20mmcase.mdl");
	}
	else
	{
		newmis.nextthink = (time + 3);
		setmodel (newmis, "progs/shell2.mdl");
	}
	newmis.think = SUB_Remove;
	newmis.touch = ShellHit;
	if (((self.current_weapon == 128) || (self.current_weapon == 256)))
	{
		newmis.skin = 0;
	}
	else
	{
		newmis.skin = 1;
	}
};

void() StingerTouch =
{
	if (other.takedamage)
	{
// ---> pablo. gg? :/
//		self.velocity == '0 0 0';
// <---
		sound(self, 3, "shambler/smack.wav", 0.8, TF_FLARE_OFF);
		return;
	}
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};

void() StingerElec =
{
	local entity te;
	self.effects = 4;
	sound(self, TF_FLARE_OFF, "weapons/lhit.wav", TF_FLARE_OFF, TF_FLARE_OFF);
// ---> pablo. gg? :/
//	self.team_no == self.owner.team_no;
// <---
	if (self.waterlevel > TF_FLARE_LIT)
	{
		te = findradius(self.origin, 950);
		while (te)
		{
			if (te.classname == "player" && te.waterlevel > TF_FLARE_LIT)
			{
				if (!(te.radsuit_finished > time))
				{
					deathmsg = 7;
					TF_T_Damage(te, self, self.owner, 250, 2, TF_FLARE_LIT);
				}
			}
			te = te.chain;
		}
		remove(self);
		return;
	}
	else
	{
		remove(self);
		return;
	}
};

void () W_LaunchStinger =
{
	local entity _l_2155;

	if ((self.no_grenades_2 < 2.000000))
	{
		sprint (self, 2.000000, "Not enough type 2 grenades... get more\n");
		return;
	}
	if (infokey(world, "drop2") == "off" || infokey(world, "drop2") == "0")
	{
		sprint (self, 2.000000, "Toasters have been disabled by the admin!\n");
		return;
	}
	self.no_grenades_2 = (self.no_grenades_2 - 2.000000);
	sound (self, 1.000000, "misc/power.wav", 1.000000, 1.000000);
	_l_2155 = spawn ();
	_l_2155.owner = self;
	_l_2155.movetype = 10.000000;
	_l_2155.solid = 2.000000;
	_l_2155.classname = "grenade";
	_l_2155.effects = 8.000000;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		_l_2155.velocity = ((((v_forward * 600.000000) + (v_up * 200.000000)) + ((crandom () * v_right) * 10.000000)) + ((crandom () * v_up) * 10.000000));
	}
	else
	{
		_l_2155.velocity = aim (self, 10000.000000);
		_l_2155.velocity = (_l_2155.velocity * 600.000000);
		_l_2155.velocity_z = 200.000000;
	}
	_l_2155.avelocity = '300.000000 300.000000 300.000000';
	_l_2155.angles = vectoangles (_l_2155.velocity);
	_l_2155.touch = StingerTouch;
	_l_2155.nextthink = (time + 3.000000);
	_l_2155.think = StingerElec;
	setmodel (_l_2155, "progs/v_spike.mdl");
	setsize (_l_2155, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
	setorigin (_l_2155, self.origin);
};

void() SpyPackRemove =
{
	sprint(self.owner, 2, "Your Ammo Trap failed...\n");
	dremove(self);
};

void () SpyPackTouch =
{

	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if ((other.team_no == self.team_no))
	{
		return;
	}
	if ((other.bugger > 0.000000))
	{
		return;
	}
	if ((other.classname == "player"))
	{
		other.ammo_shells = 0.000000;
		other.ammo_nails = 0.000000;
		other.ammo_rockets = 0.000000;
		other.ammo_cells = 0.000000;
		other.currentammo = 0.000000;
		other.no_grenades_1 = 0.000000;
		other.no_grenades_2 = 0.000000;
		sprint (other, 2.000000, "Your ammo has been robbed!\n");
		sound (self, 3.000000, "weapons/lock4.wav", 1.000000, 1.000000);
		sprint (self.owner, 2.000000, "Your ammo trap worked!\n");
		dremove (self);
	}
};

void() SpyPack =
{
	local entity te;
	te = find(world, classname, "drop1");
	while (te)
	{
		if (te.owner == self)
		{
			sprint(self, 2, "1 ammo trap at a time!\n");
			return;
		}
		te = find(te, classname, "drop1");
	}
	sprint(self, 2, "You set an Ammo Trap!\n");
	sound(self, 3, "weapons/lock4.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis = spawn();
	newmis.owner = self;
	newmis.enemy = self;
	newmis.health = time;
	newmis.weapon = TF_FLARE_LIT;
	newmis.movetype = 6;
	newmis.solid = TF_FLARE_OFF;
	newmis.team_no = self.team_no;
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = v_forward * 100 + v_up * 200;
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		newmis.velocity = newmis.velocity * 100;
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '0 300 0';
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin);
	newmis.nextthink = time + 180;
	newmis.think = SpyPackRemove;
	newmis.touch = SpyPackTouch;
	newmis.classname = "drop1";
	setmodel(newmis, "progs/backpack.mdl");
};

void() RemoveLavaPool =
{
	sprint(self.owner, 2, "Your Lava has cooled...\n");
	sound(self, 4, "misc/null.wav", TF_FLARE_LIT, TF_FLARE_OFF);
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove(self);
};

void() LavaTouch =
{
	if (other.classname != "player" && other.classname != "bot")
	{
		return;
	}
	if (other.health <= TF_FLARE_LIT)
	{
		return;
	}
	if (other.team_no < TF_FLARE_OFF)
	{
		return;
	}
	if (other.takedamage)
	{
		deathmsg = 15;
		TF_T_Damage(other, self.owner, self.owner, 2, TF_FLARE_LIT, 16);
		if (random() < 0.1)
		{
			sound(other, TF_FLARE_LIT, "misc/vapeur2.wav", 0.4, TF_FLARE_OFF);
		}
		else
		{
			if (random() > 0.6)
			{
				sound(other, TF_FLARE_LIT, "player/inh2o.wav", 0.8, TF_FLARE_OFF);
			}
		}
		if (other.classname != "bot")
		{
			stuffcmd(other, "bf\n");
		}
		if (other.team_no == self.owner.team_no)
		{
			return;
		}
		other.origin_x = self.origin_x;
		other.origin_y = self.origin_y;
	}
};

void() LavaBallTouch =
{
	if (other == self.owner)
	{
		return;
	}
	sound(self, TF_FLARE_OFF, "zombie/z_miss.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (other.takedamage)
	{
		if (other.classname != "player")
		{
			return;
		}
		if (other.health <= TF_FLARE_LIT)
		{
			return;
		}
		if (other.team_no < TF_FLARE_OFF)
		{
			return;
		}
		if (other.team_no == self.owner.team_no)
		{
			return;
		}
		deathmsg = 15;
		TF_T_Damage(other, self, self.owner, 20, TF_FLARE_LIT, 16);
	}
};

void() LavaBecome =
{
	if (self.waterlevel > TF_FLARE_OFF)
	{
		dremove(self);
	}
	setmodel(self, "progs/lavapool.mdl");
	self.avelocity = '0 0 0';
	self.effects = 8;
	deathmsg = 15;
	self.classname = "timer";
	sound(self, 4, "weapons/lavapool.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	self.angles_y = TF_FLARE_LIT;
	self.angles_x = TF_FLARE_LIT;
	self.angles_z = TF_FLARE_LIT;
	setsize(self, '-12 -12 0', '12 12 2');
	self.nextthink = time + 30;
	self.think = RemoveLavaPool;
	self.touch = LavaTouch;
};

void() LavaPool =
{
	if (self.has_syringe != TF_FLARE_OFF)
	{
		sprint(self, 2, "You get 1 Lava Pool at a time!\n");
		return;
	}
	self.has_syringe = TF_FLARE_LIT;

	sound(self, 3, "weapons/throw.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis = spawn();
	newmis.classname = "timer";
	newmis.owner = self;
	newmis.team_no = self.team_no;
	newmis.health = time;
	newmis.weapon = TF_FLARE_LIT;
	newmis.movetype = 6;
	newmis.solid = TF_FLARE_OFF;
	newmis.team_no = self.team_no;
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = v_forward * 400 + v_up * 200;
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		newmis.velocity = newmis.velocity * 400;
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '300 300 300';
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin);
	newmis.nextthink = time + 2;
	newmis.think = LavaBecome;
	newmis.touch = LavaBallTouch;
	setmodel(newmis, "progs/lavaball.mdl");
};

void() s_explode1 = [0, s_explode2]
{
};

void() s_explode2 = [1, s_explode3]
{
};

void() s_explode3 = [2, s_explode4]
{
};

void() s_explode4 = [3, s_explode5]
{
};

void() s_explode5 = [4, s_explode6]
{
};

void() s_explode6 = [5, SUB_Remove]
{
};

void() s2_explode1 = [0, s2_explode2]
{
};

void() s2_explode2 = [1, s2_explode3]
{
};

void() s2_explode3 = [2, s2_explode4]
{
};

void() s2_explode4 = [3, s2_explode5]
{
};

void() s2_explode5 = [4, s2_explode6]
{
};

void() s2_explode6 = [5, s2_explode7]
{
};

void() s2_explode7 = [6, s2_explode8]
{
};

void() s2_explode8 = [7, SUB_Remove]
{
};

void() BecomeExplosion =
{
	dremove(self);
};

float(float tno) num_team_pipebombs =
{
	if (tno == TF_FLARE_OFF)
	{
		return num_team_pipebombs_1;
	}
	else
	{
		if (tno == 2)
		{
			return num_team_pipebombs_2;
		}
		else
		{
			if (tno == 3)
			{
				return num_team_pipebombs_3;
			}
			else
			{
				if (tno == 4)
				{
					return num_team_pipebombs_4;
				}
			}
		}
	}
	return TF_FLARE_LIT;
};

void(float tno) ExplodeOldPipebomb =
{
	local entity old;
	local float index;
	if (tno != TF_FLARE_LIT)
	{
		index = num_team_pipebombs(tno);
		index = index - 30 / number_of_teams;
	}
	else
	{
		index = num_world_pipebombs - 30;
	}
	old = find(world, classname, "pipebomb");
	while (index > TF_FLARE_LIT)
	{
		if (old == world)
		{
			dprint("*** ERROR: ExplodeOldPipebomb. ***\n");
			dprint("*** Please report this.        ***\n");
			num_world_pipebombs = TF_FLARE_LIT;
			num_team_pipebombs_1 = TF_FLARE_LIT;
			num_team_pipebombs_2 = TF_FLARE_LIT;
			num_team_pipebombs_3 = TF_FLARE_LIT;
			num_team_pipebombs_4 = TF_FLARE_LIT;
			return;
		}
		if (old.owner.team_no == tno || tno == TF_FLARE_LIT)
		{
			old.nextthink = time + 0.5;
			index = index - TF_FLARE_OFF;
		}
		old = find(old, classname, "pipebomb");
	}
};

void(float tno) increment_team_pipebombs =
{
	if (tno == TF_FLARE_OFF)
	{
		num_team_pipebombs_1 = num_team_pipebombs_1 + TF_FLARE_OFF;
	}
	else
	{
		if (tno == 2)
		{
			num_team_pipebombs_2 = num_team_pipebombs_2 + TF_FLARE_OFF;
		}
		else
		{
			if (tno == 3)
			{
				num_team_pipebombs_3 = num_team_pipebombs_3 + TF_FLARE_OFF;
			}
			else
			{
				if (tno == 4)
				{
					num_team_pipebombs_4 = num_team_pipebombs_4 + TF_FLARE_OFF;
				}
			}
		}
	}
};

void(float tno) decrement_team_pipebombs =
{
	if (tno == TF_FLARE_OFF)
	{
		num_team_pipebombs_1 = num_team_pipebombs_1 - TF_FLARE_OFF;
	}
	else
	{
		if (tno == 2)
		{
			num_team_pipebombs_2 = num_team_pipebombs_2 - TF_FLARE_OFF;
		}
		else
		{
			if (tno == 3)
			{
				num_team_pipebombs_3 = num_team_pipebombs_3 - TF_FLARE_OFF;
			}
			else
			{
				if (tno == 4)
				{
					num_team_pipebombs_4 = num_team_pipebombs_4 - TF_FLARE_OFF;
				}
			}
		}
	}
};

void() GrenadeExplode =
{
	if (self.classname == "pipebomb")
	{
		num_world_pipebombs = num_world_pipebombs - TF_FLARE_OFF;
		decrement_team_pipebombs(self.owner.team_no);
	}
	deathmsg = self.weapon;
	if ((self.weapon == 9.000000))
	{
		self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	}
	if ((self.weapon == 10.000000))
	{
// This is added from 11.11.04 - used to be (self.owner.active_grenades_2 - 0.166667);
// but I dunno how the hell that can make sense - I figure it's a decompiler error, so
// I changed it to 1.000000.
		self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
		if ((ftos (self.owner.active_grenades_2) == " -0.0"))
		{
			self.owner.active_grenades_2 = 0.000000;
		}
	}
	self.weapon = 40;
	self.weapon = 10;
//	if (40 || 10)
//	{
		T_RadiusDamage(self, self.owner, 120, world);
//	}
//	else
//	{
//		T_RadiusDamage(self, self.owner, 80, world);
//	}
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	BecomeExplosion();
	dremove(self);
};

void() GrenadeTouch =
{
	if (other == self.owner)
	{
		return;
	}
	if (other.takedamage == 2)
	{
		GrenadeExplode();
		return;
	}
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};

void() W_FireGrenade =
{
	if (self.option == TF_FLARE_OFF)
	{
		self.currentammo = self.ammo_rockets = self.ammo_rockets - 2;
	}
	else
	{
		if (self.option4 == 1.000000)
		{
			self.currentammo = self.ammo_rockets = self.ammo_rockets - 2;
		}
		else
		{
			self.currentammo = self.ammo_rockets = self.ammo_rockets - TF_FLARE_OFF;
		}
	}
	sound(self, TF_FLARE_OFF, "weapons/launch.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	KickPlayer(-2, self);
	newmis = spawn();
	newmis.owner = self;
	newmis.movetype = 10;
	newmis.solid = 2;
	if (self.weaponmode == TF_FLARE_LIT)
	{
		newmis.weapon = 5;
		newmis.classname = "grenade";
		newmis.skin = TF_FLARE_OFF;
		newmis.touch = GrenadeTouch;
		newmis.nextthink = time + 2.5;
	}
	else
	{
		if (self.team_no != TF_FLARE_LIT)
		{
			increment_team_pipebombs(self.team_no);
			if (num_team_pipebombs(self.team_no) > 30 / number_of_teams)
			{
				ExplodeOldPipebomb(self.team_no);
			}
		}
		else
		{
			num_world_pipebombs = num_world_pipebombs + TF_FLARE_OFF;
			if (num_world_pipebombs > 30)
			{
				ExplodeOldPipebomb(TF_FLARE_LIT);
			}
		}
		newmis.classname = "pipebomb";
		newmis.skin = 2;
		newmis.touch = PipebombTouch;
		newmis.nextthink = time + 120;
		newmis.weapon = 11;
	}
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		if (self.option == TF_FLARE_OFF)
		{
			newmis.velocity = v_forward * 1200 + v_up * 200 + crandom() * v_right * 10 + crandom() * v_up * 10;
		}
		else
		{
			newmis.velocity = v_forward * 600 + v_up * 200 + crandom() * v_right * 10 + crandom() * v_up * 10;
		}
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		if (self.option == TF_FLARE_OFF)
		{
			newmis.velocity = newmis.velocity * 1200;
		}
		else
		{
			newmis.velocity = newmis.velocity * 600;
		}
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '300 300 300';
	newmis.angles = vectoangles(newmis.velocity);
	newmis.think = GrenadeExplode;
	setmodel(newmis, "progs/grenade2.mdl");
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin);
};

void() HoloHumm =
{
	self.playerclass = self.playerclass + TF_FLARE_OFF;
	self.nextthink = time + TF_FLARE_OFF;
	sound(self, TF_FLARE_LIT, "ambient/100hzhum.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.playerclass > 4)
	{
		WriteByte(4, 23);
		WriteByte(4, 11);
		WriteCoord(4, self.origin_x);
		WriteCoord(4, self.origin_y);
		WriteCoord(4, self.origin_z);
		multicast(self.origin, TF_FLARE_OFF);
		if (self.playerclass > 4)
		{
			self.owner.has_holo = TF_FLARE_OFF;
			self.think = SUB_Remove;
		}
	}
};

void() HoloDood =
{
	local entity holo;
	sound(self, TF_FLARE_OFF, "weapons/railgr1a.wav", 0.6, TF_FLARE_OFF);
	holo = spawn();
	holo.owner = self;
	holo.origin = self.origin + '0 0 24';
	holo.angles_y = self.angles_y;
	holo.angles_x = self.angles_x;
	holo.skin = self.skin;
	holo.frame = self.frame;
	holo.colormap = self.colormap;
	holo.flags = 256;
	holo.solid = TF_FLARE_OFF;
	holo.effects = 8;
	holo.movetype = 6;
	setmodel(holo, "progs/player.mdl");
	setsize(holo, '-16 -16 -24', '16 16 32');
	holo.classname = "holo";
	holo.playerclass = TF_FLARE_LIT;
	holo.nextthink = time + TF_FLARE_OFF;
	holo.think = HoloHumm;
	WriteByte(4, 23);
	WriteByte(4, 11);
	WriteCoord(4, holo.origin_x);
	WriteCoord(4, holo.origin_y);
	WriteCoord(4, holo.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
};

void() SuperLeap =
{

	if (!airscout)
	{
		sprint(self, 2, "JetPack disabled by Admin!\n");
		return;
	}
	if (self.ammo_cells < 24)
	{
		sprint(self, 2, "Insufficient power... get more cells\n");
		return;
	}
	if (self.tfstate & 65536)
	{
		return;
	}
	self.jet_time = time + 3;
	sound(self, TF_FLARE_OFF, "weapons/jetjump.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	W_FireFlame();
	muzzleflash();
	self.velocity = v_forward * 900 + '0 0 250' + v_up * 100;
	stuffcmd(self, "bf\n");
	self.ammo_cells = self.ammo_cells - 23;
	self.impulse = TF_FLARE_LIT;
};

void () MagTimer =
{
	local entity _l_2374;
	local string _l_2375;

	_l_2374 = self.owner;
	_l_2374.option5 = (_l_2374.option5 - 0.500000);
	_l_2375 = ftos (_l_2374.option5);
	sound (_l_2374, 0.000000, "ambient/100hzhum.wav", 1.000000, 1.000000);
	_l_2374.origin = self.origin;
	CenterPrint2 (_l_2374, "You are stuck on a mag mine!\n", _l_2375);
	if ((_l_2374.option5 < 2.000000))
	{
		_l_2374.option5 = 0.000000;
		sprint (_l_2374.enemy, 2.000000, "Your Mag Mine died...\n");
		_l_2374.enemy.has_syringe = 1.000000;
		remove (self);
		return;
	}
	self.nextthink = (time + 0.500000);
};

void () MagMineActivate =
{

	if ((other.option == 0.000000))
	{
		self.owner.has_syringe = 1.000000;
		newmis = spawn ();
		newmis.classname = "timer";
		newmis.netname = " FlashTimer";
		newmis.team_no = self.owner.team_no;
		newmis.owner = other;
		other.enemy = self.owner;
		newmis.think = MagTimer;
		newmis.nextthink = (time + 1.000000);
		newmis.origin = other.origin;
		other.is_squating = 0.000000;
	}
	other.option5 = (floor ((other.armorvalue * 0.250000)) + 3.000000);
	if ((other.option5 > 15.000000))
	{
		other.option5 = 15.000000;
	}
};

void () FlashTimer2 =
{
	local entity _l_2398;
	local string _l_2399;

	_l_2398 = self.owner;
	_l_2398.FlashTime = (_l_2398.FlashTime - 0.100000);
	if ((_l_2398.FlashTime < 0.000000))
	{
		_l_2398.FlashTime = 0.000000;
		stuffcmd (_l_2398, "v_cshift 0\n");
		remove (self);
		return;
	}
	if ((_l_2398.FlashTime < 1.700000))
	{
		_l_2399 = ftos ((_l_2398.FlashTime * 150.000000));
		stuffcmd (_l_2398, "v_cshift ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, " ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, " ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, " ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, "\n");
	}
	if ((_l_2398.FlashTime >= 1.700000))
	{
		stuffcmd (_l_2398, "v_cshift 255 255 255 255\n");
	}
	if (((_l_2398.client != "zquake") && (_l_2398.client != "fuhquake")))
	{
		stuffcmd (_l_2398, "gl_polyblend 1\n");
	}
	if ((_l_2398.client == "moreqw"))
	{
		stuffcmd (_l_2398, "gl_cshiftpercent 100\n");
	}
	self.nextthink = (time + 0.100000);
};

void () FlashGrenadeExplode2 =
{

	self.owner.has_syringe = 1.000000;
	self.effects = (self.effects | 4.000000);
	WriteByte (4.000000, 23.000000);
	WriteByte (4.000000, 4.000000);
	WriteCoord (4.000000, self.origin_x);
	WriteCoord (4.000000, self.origin_y);
	WriteCoord (4.000000, self.origin_z);
	multicast (self.origin, 1.000000);
	if ((other.FlashTime == 0.000000))
	{
		newmis = spawn ();
		newmis.classname = "timer";
		newmis.netname = "FlashTimer2";
		newmis.team_no = self.owner.team_no;
		newmis.owner = other;
		newmis.think = FlashTimer2;
		newmis.nextthink = (time + 0.100000);
	}
//	other.FlashTime = 2.500000; //changed by request of Misery
	other.FlashTime = 3.000000;
	stuffcmd (other, "v_cshift 255 255 255 255\n");
};

void () W_FireAxe =
{
	local vector source;
	local vector org;
	local vector def;

	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	if (trace_ent.takedamage)
	{
		trace_ent.axhitme = 1;
		SpawnBlood (org, 20);
		if (((self.playerclass != 8) || (trace_ent.classname != "player")))
		{
			deathmsg = 17;
			TF_T_Damage (trace_ent, self, self, 20, 2, 0.000000);
		}
		else
		{
			self.weaponmode = 1;
			self.weaponmodel = "progs/v_knife2.mdl";
			makevectors (trace_ent.v_angle);
			def = v_right;
			makevectors (self.v_angle);
			if ((crossproduct (def, v_forward) > 0.000000))
			{
				deathmsg = 22;
				TF_T_Damage (trace_ent, self, self, 120, 2, 0.000000);
			}
			else
			{
				deathmsg = 17;
				TF_T_Damage (trace_ent, self, self, 40, 2, 0.000000);
			}
		}
	}
	else
	{
		sound (self, 1, "player/axhit2.wav", 1, 1);
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
};

void () W_FireSpanner =
{
	local vector source;
	local vector org;
	local float healam;
	local entity te;

	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	if ((trace_ent.goal_activation & 8))
	{
		if (Activated (trace_ent, self))
		{
			DoResults (trace_ent, self, 1);
			if ((trace_ent.classname == "func_button"))
			{
				trace_ent.enemy = self;
				other = self;
				self = trace_ent;
				self.dont_do_triggerwork = 1;
				button_fire ();
				self = other;
			}
		}
		else
		{
			if ((trace_ent.else_goal != 0.000000))
			{
				te = Findgoal (trace_ent.else_goal);
				if (te)
				{
					DoResults (te, self, (trace_ent.goal_result & 2));
				}
			}
			else
			{
				sound (self, 1, "player/axhit2.wav", 1, 1);
				WriteByte (4, 23);
				WriteByte (4, 2);
				WriteByte (4, 3);
				WriteCoord (4, org_x);
				WriteCoord (4, org_y);
				WriteCoord (4, org_z);
				multicast (org, 2);
			}
		}
		return;
	}
	if (trace_ent.takedamage)
	{
		if ((trace_ent.classname == "building_dispenser"))
		{
			Engineer_UseDispenser (trace_ent);
			return;
		}
		else
		{
			if ((trace_ent.classname == "building_sentrygun"))
			{
				Engineer_UseSentryGun (trace_ent);
				return;
			}
			else
			{
				if ((trace_ent.classname == "building_sentrygun_base"))
				{
					if (trace_ent.oldenemy)
					{
						Engineer_UseSentryGun (trace_ent.oldenemy);
					}
					return;
				}
				else
				{
// pablo. no telsas in mtf.
//					if ((trace_ent.classname == "building_tesla"))
//					{
//						Engineer_UseTesla (trace_ent);
//						return;
//					}
//					else
//					{
						if ((trace_ent.classname == "player"))
						{
							if (((((trace_ent.team_no == self.team_no) && (self.team_no != 0.000000)) && teamplay) || coop))
							{
								healam = 10;
								if ((self.ammo_cells < healam))
								{
									healam = self.ammo_cells;
								}
								if ((trace_ent.armortype == 0.000000))
								{
									return;
								}
								if (((trace_ent.maxarmor - trace_ent.armorvalue) < (healam * 4)))
								{
									healam = ceil (((trace_ent.maxarmor - trace_ent.armorvalue) / 4));
								}
								if ((healam > 0.000000))
								{
									trace_ent.armorvalue = (trace_ent.armorvalue + (healam * 4));
									if ((trace_ent.armorvalue > trace_ent.maxarmor))
									{
										trace_ent.armorvalue = trace_ent.maxarmor;
									}
									self.ammo_cells = (self.ammo_cells - healam);
									sound (trace_ent, 1, "items/repair.wav", 1, 1);
									WriteByte (4, 23);
									WriteByte (4, 2);
									WriteByte (4, 3);
									WriteCoord (4, org_x);
									WriteCoord (4, org_y);
									WriteCoord (4, org_z);
									multicast (org, 2);
									W_SetCurrentAmmo ();
								}
								return;
							}
						}
						trace_ent.axhitme = 1;
						SpawnBlood (org, 20);
						deathmsg = 32;
						TF_T_Damage (trace_ent, self, self, 20, 2, 0.000000);
					}
				}
//			}
		}
	}
	else
	{
		sound (self, 1, "player/axhit2.wav", 1, 1);
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
};

void () W_FireMedikit =
{
	local vector _l_2511;
	local vector _l_2514;
	local float _l_2517;
	local entity _l_2518;

	_l_2511 = self.origin + '0.000000 0.000000 16.000000';
	traceline (_l_2511, (_l_2511 + (v_forward * 64.000000)), 0.000000, self);
	if ((trace_fraction == 1.000000))
	{
		return;
	}
	_l_2514 = trace_endpos - (v_forward * 4.000000);
	if (trace_ent.takedamage)
	{
		if ((trace_ent.classname == "building_dispenser"))
		{
			trace_ent.skin = 1.000000;
			return;
		}
		if (((trace_ent.classname == "player") && (trace_ent.bugger == 0.000000)))
		{
			if ((((trace_ent.team_no == self.team_no) && (self.team_no != 0.000000)) || coop))
			{
				_l_2517 = 200.000000;
				if ((trace_ent.leg_damage > 1.000000))
				{
					sprint (trace_ent, 2.000000, "Your leg wound has been healed!\n");
				}
				TeamFortress_SetSpeed (trace_ent);
				_l_2518 = find (world, classname, "timer");
				while ((((_l_2518.owner != trace_ent) || (_l_2518.think != ConcussionGrenadeTimer)) && (_l_2518 != world)))
				{
					_l_2518 = find (_l_2518, classname, "timer");
				}
				if ((_l_2518 != world))
				{
					stuffcmd (trace_ent, "v_idlescale 0\n");
					SpawnBlood (_l_2514, 20.000000);
					sprint (trace_ent, 2.000000, "you have been healed of your concussion\n");
					if ((_l_2518.team_no != self.team_no))
					{
						self.real_frags = (self.real_frags + 1.000000);
						if (!(toggleflags & 128.000000))
						{
							self.frags = self.real_frags;
						}
					}
					dremove (_l_2518);
				}
				if ((trace_ent.tfstate & 16384.000000))
				{
					_l_2518 = find (world, classname, "timer");
					while ((((_l_2518.owner != trace_ent) || (_l_2518.think != HallucinationTimer)) && (_l_2518 != world)))
					{
						_l_2518 = find (_l_2518, classname, "timer");
					}
					if ((_l_2518 != world))
					{
						stuffcmd (trace_ent, "v_idlescale 0\n");
						trace_ent.tfstate = (trace_ent.tfstate - (trace_ent.tfstate & 16384.000000));
						SpawnBlood (_l_2514, 20.000000);
						sprint (trace_ent, 2.000000, "you have been healed of your hallucinations\n");
						if ((_l_2518.team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1.000000);
							if (!(toggleflags & 128.000000))
							{
								self.frags = self.real_frags;
							}
						}
						dremove (_l_2518);
					}
					else
					{
						dprint ("Warning: Error in Hallucination Timer logic.\n");
					}
				}
				if ((trace_ent.tfstate & 32768.000000))
				{
					_l_2518 = find (world, classname, "timer");
					while ((((_l_2518.owner != trace_ent) || (_l_2518.think != TranquiliserTimer)) && (_l_2518 != world)))
					{
						_l_2518 = find (_l_2518, classname, "timer");
					}
					if ((_l_2518 != world))
					{
						trace_ent.tfstate = (trace_ent.tfstate - (trace_ent.tfstate & 32768.000000));
						TeamFortress_SetSpeed (trace_ent);
						SpawnBlood (_l_2514, 20.000000);
						stuffcmd (trace_ent, "v_cshift 0 0 0 0\n");
						sprint (trace_ent, 2.000000, "you have been healed of your tranquilisation\n");
						if ((_l_2518.team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1.000000);
							if (!(toggleflags & 128.000000))
							{
								self.frags = self.real_frags;
							}
						}
						dremove (_l_2518);
					}
					else
					{
						dprint ("Warning: Error in Tranquilisation Timer logic.\n");
					}
				}
				if ((trace_ent.FlashTime > 0.000000))
				{
					_l_2518 = find (world, netname, "flashtimer");
					while ((((_l_2518.owner != trace_ent) || (_l_2518.classname != "timer")) && (_l_2518 != world)))
					{
						_l_2518 = find (_l_2518, netname, "flashtimer");
					}
					if ((_l_2518 != world))
					{
						trace_ent.FlashTime = 0.000000;
						SpawnBlood (_l_2514, 20.000000);
						stuffcmd (trace_ent, "v_cshift 0 0 0 0\n");
						if ((_l_2518.team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1.000000);
							if (!(toggleflags & 128.000000))
							{
								self.frags = self.real_frags;
							}
						}
						dremove (_l_2518);
					}
					else
					{
						dprint ("Warning: Error in Flash Timer logic.\n");
						trace_ent.FlashTime = 0.000000;
					}
				}
				if ((trace_ent.tfstate & 16.000000))
				{
					_l_2517 = rint ((trace_ent.health / 2.000000));
					trace_ent.tfstate = (trace_ent.tfstate - (trace_ent.tfstate & 16.000000));
					deathmsg = 23.000000;
					T_Damage (trace_ent, self, self, _l_2517);
					SpawnBlood (_l_2514, 30.000000);
					sprint (trace_ent, 2.000000, "Your infection is cured!\n");
					bprint (1.000000, trace_ent.netname);
					bprint (1.000000, "'s infection was cured by ");
					bprint (1.000000, self.netname);
					bprint (1.000000, "\n");
					if ((self.classname == "player"))
					{
						sprint (self, 2.000000, "You have healed ");
						sprint (self, 2.000000, trace_ent.netname);
						sprint (self, 2.000000, " of the infection.\n");
						if ((trace_ent.infection_team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1.000000);
							if (!(toggleflags & 128.000000))
							{
								self.frags = self.real_frags;
							}
						}
					}
					return;
				}
				if ((trace_ent.numflames > 0.000000))
				{
					sound (trace_ent, 1.000000, "items/r_item1.wav", 1.000000, 1.000000);
					trace_ent.numflames = 0.000000;
					sprint (trace_ent, 2.000000, "The flames have been doused!\n");
					if ((self.classname == "player"))
					{
						sprint (self, 1.000000, "You have put out ");
						sprint (self, 1.000000, trace_ent.netname);
						sprint (self, 1.000000, "'s fire.\n");
					}
					return;
				}
				if (((_l_2517 > 0.000000) && (trace_ent.health < trace_ent.max_health)))
				{
					sound (trace_ent, 1.000000, "items/r_item1.wav", 1.000000, 1.000000);
					trace_ent.axhitme = 1.000000;
					SpawnBlood (_l_2514, 20.000000);
					T_Heal (trace_ent, _l_2517, 0.000000);
					if (medicarmorheal)
					{
						trace_ent.armorvalue = (trace_ent.armorvalue + (trace_ent.maxarmor / 5.000000));
						if ((trace_ent.armortype == 0.000000))
						{
							trace_ent.armortype = 0.300000;
							trace_ent.items = (self.items | 8192.000000);
						}
						if ((trace_ent.armorvalue > trace_ent.maxarmor))
						{
							trace_ent.armorvalue = trace_ent.maxarmor;
						}
					}
				}
				else
				{
					if (((trace_ent.health >= trace_ent.max_health) && (trace_ent.health < (trace_ent.max_health + 51.000000))))
					{
						_l_2517 = 5.000000;
						if ((_l_2517 > (self.ammo_medikit * 5.000000)))
						{
							_l_2517 = self.ammo_medikit * 5.000000;
						}
						if ((_l_2517 > 0.000000))
						{
							sound (trace_ent, 3.000000, "items/r_item2.wav", 1.000000, 1.000000);
							T_Heal (trace_ent, _l_2517, 1.000000);
							self.ammo_medikit = (self.ammo_medikit - rint ((_l_2517 / 5.000000)));
							if (medicarmorheal)
							{
								if (((self.ammo_cells >= 15.000000) && (trace_ent.armorvalue < trace_ent.maxarmor)))
								{
									trace_ent.armorvalue = (trace_ent.armorvalue + (trace_ent.maxarmor / 5.000000));
									if ((trace_ent.armortype == 0.000000))
									{
										trace_ent.armortype = 0.300000;
										trace_ent.items = (self.items | 8192.000000);
									}
									if ((trace_ent.armorvalue > trace_ent.maxarmor))
									{
										trace_ent.armorvalue = trace_ent.maxarmor;
									}
									self.ammo_cells = (self.ammo_cells - 15.000000);
								}
							}
							if (!(trace_ent.items & 65536.000000))
							{
								trace_ent.items = (trace_ent.items | 65536.000000);
								newmis = spawn ();
								newmis.nextthink = (time + 5.000000);
								newmis.think = item_megahealth_rot;
								newmis.owner = trace_ent;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		sound (self, 1.000000, "player/axhit2.wav", 1.000000, 1.000000);
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 2.000000);
		WriteByte (4.000000, 3.000000);
		WriteCoord (4.000000, _l_2514_x);
		WriteCoord (4.000000, _l_2514_y);
		WriteCoord (4.000000, _l_2514_z);
		multicast (_l_2514, 2.000000);
	}
};


void () W_FireBioweapon =
{
	local vector _l_2533;
	local vector _l_2536;
	local entity _l_2540;

	_l_2533 = self.origin + '0.000000 0.000000 16.000000';
	traceline (_l_2533, (_l_2533 + (v_forward * 64.000000)), 0.000000, self);
	if ((trace_fraction == 1.000000))
	{
		return;
	}
	_l_2536 = trace_endpos - (v_forward * 4.000000);
	if (trace_ent.takedamage)
	{
		if ((trace_ent.classname == "building_dispenser"))
		{
			trace_ent.skin = 1.000000;
			return;
		}
		if (((trace_ent.classname == "player") && (trace_ent.bugger == 0.000000)))
		{
			if (((((trace_ent.team_no != self.team_no) && (self.team_no != 0.000000)) && teamplay) || (teamplay == 0.000000)))
			{
				trace_ent.axhitme = 1.000000;
				SpawnBlood (_l_2536, 20.000000);
				deathmsg = 14.000000;
				T_Damage (trace_ent, self, self, 10.000000);
				if ((trace_ent.playerclass == 5.000000))
				{
					return;
				}
				trace_ent.tfstate = (trace_ent.tfstate | 16.000000);
				_l_2540 = spawn ();
				_l_2540.classname = "timer";
				_l_2540.owner = trace_ent;
				_l_2540.nextthink = (time + 2.000000);
				_l_2540.think = BioInfection_Decay;
				_l_2540.enemy = self;
				trace_ent.infection_team_no = self.team_no;
				sprint (self, 2.000000, "Your BioAxe has Infected an enemy!\n");
			}
		}
		else
		{
			if ((trace_ent.flags & 32.000000))
			{
				if ((trace_ent.classname == "monster_zombie"))
				{
					T_Damage (trace_ent, self, self, 200.000000);
				}
				trace_ent.axhitme = 1.000000;
				SpawnBlood (_l_2536, 20.000000);
				T_Damage (trace_ent, self, self, 10.000000);
				_l_2540 = spawn ();
				_l_2540.classname = "timer";
				_l_2540.nextthink = (time + 2.000000);
				_l_2540.think = BioInfection_MonsterDecay;
				_l_2540.owner = self;
				_l_2540.enemy = trace_ent;
			}
			else
			{
				trace_ent.axhitme = 1.000000;
				SpawnBlood (_l_2536, 30.000000);
				T_Damage (trace_ent, self, self, 40.000000);
			}
		}
	}
	else
	{
		sound (self, 1.000000, "player/axhit2.wav", 1.000000, 1.000000);
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 2.000000);
		WriteByte (4.000000, 3.000000);
		WriteCoord (4.000000, _l_2536_x);
		WriteCoord (4.000000, _l_2536_y);
		WriteCoord (4.000000, _l_2536_z);
		multicast (_l_2536, 2.000000);
	}
};


vector () wall_velocity =
{
	local vector vel;

	vel = normalize (self.velocity);
	vel = normalize (((vel + (v_up * (random () - 0.5))) + (v_right * (random () - 0.5))));
	vel = (vel + (2 * trace_plane_normal));
	vel = (vel * 200);
	return (vel);
};

void (vector org,vector vel) SpawnMeatSpray =
{
	local entity missile;

	missile = spawn ();
	missile.owner = self;
	missile.movetype = 10;
	missile.solid = 0.000000;
	makevectors (self.angles);
	missile.velocity = vel;
	missile.velocity_z = ((missile.velocity_z + 250) + (50 * random ()));
	missile.avelocity = '3000 1000 2000';
	missile.nextthink = (time + 1);
	missile.think = SUB_Remove;
	setmodel (missile, "progs/zom_gib.mdl");
	setsize (missile, '0 0 0', '0 0 0');
	setorigin (missile, org);
};

void (vector org,float damage) SpawnBlood =
{
	WriteByte (4, 23);
	WriteByte (4, 12);
	WriteByte (4, 1);
	WriteCoord (4, org_x);
	WriteCoord (4, org_y);
	WriteCoord (4, org_z);
	multicast (org, 2);
};

void (float damage) spawn_touchblood =
{
	local vector vel;

	vel = (wall_velocity () * 0.2);
	SpawnBlood ((self.origin + (vel * 0.01)), damage);
};

void (vector org,vector vel) SpawnChunk =
{
	particle (org, (vel * 0.02), 0.000000, 10);
};
entity multi_ent;
float multi_damage /* = 0.000000 */;
vector blood_org /* = '0 0 0' */;
float blood_count /* = 0.000000 */;
vector puff_org /* = '0 0 0' */;
float puff_count /* = 0.000000 */;

void () ClearMultiDamage =
{
	multi_ent = world;
	multi_damage = 0.000000;
	blood_count = 0.000000;
	puff_count = 0.000000;
};

void () ApplyMultiDamage =
{
	if (!multi_ent)
	{
		return;
	}
	TF_T_Damage (multi_ent, self, self, multi_damage, 2, 1);
};

void (entity hit,float damage) AddMultiDamage =
{
	if (!hit)
	{
		return;
	}
	if ((hit != multi_ent))
	{
		ApplyMultiDamage ();
		multi_damage = damage;
		multi_ent = hit;
	}
	else
	{
		multi_damage = (multi_damage + damage);
	}
};

void () Multi_Finish =
{
	if (puff_count)
	{
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, puff_count);
		WriteCoord (4, puff_org_x);
		WriteCoord (4, puff_org_y);
		WriteCoord (4, puff_org_z);
		multicast (puff_org, 2);
	}
	if (blood_count)
	{
		WriteByte (4, 23);
		WriteByte (4, 12);
		WriteByte (4, blood_count);
		WriteCoord (4, blood_org_x);
		WriteCoord (4, blood_org_y);
		WriteCoord (4, blood_org_z);
		multicast (puff_org, 2);
	}
};

void (float damage,vector dir) TraceAttack =
{
	local vector vel;
	local vector org;

	vel = normalize (((dir + (v_up * crandom ())) + (v_right * crandom ())));
	vel = (vel + (2 * trace_plane_normal));
	vel = (vel * 200);
	org = (trace_endpos - (dir * 4));

	if (trace_ent.takedamage)
	{
		blood_count = (blood_count + 1);
		blood_org = org;
		AddMultiDamage (trace_ent, damage);
	}
	else
	{
		puff_count = (puff_count + 1);
	}
};

void (float shotcount,vector dir,vector spread) FireBullets =
{
	local vector direction;
	local vector src;

	makevectors (self.v_angle);
	src = (self.origin + (v_forward * 10));
	src_z = (self.absmin_z + (self.size_z * 0.7));
	ClearMultiDamage ();
	traceline (src, (src + (dir * 2048)), 0.000000, self);
	puff_org = (trace_endpos - (dir * 4));
	while ((shotcount > 0.000000))
	{
		direction = ((dir + ((crandom () * spread_x) * v_right)) + ((crandom () * spread_y) * v_up));
		traceline (src, (src + (direction * 2048)), 0.000000, self);
		if ((trace_fraction != 1.000000))
		{
			if (((self.weapon == 3.000000) && engbat))
			{
				TraceAttack (2.000000, direction);
			}
			else
			{
				if ((self.weapon != 32768.000000))
				{
					TraceAttack (4.000000, direction);
				}
				else
				{
					TraceAttack (9.000000, direction);
				}
			}
		}
		shotcount = (shotcount - 1);
	}
	ApplyMultiDamage ();
	Multi_Finish ();
};

void () W_FireShotgun =
{
	local vector dir;

	sound (self, 1, "weapons/guncock.wav", 1, 1);
	KickPlayer (-2.000000, self);
	self.ammo_shells = (self.ammo_shells - 1);
	self.currentammo = (self.ammo_shells);
	EjectShell ();
	dir = aim (self, 100000);
	deathmsg = 1;
	FireBullets (6, dir, '0.04 0.04 0');
};

void () W_FireSuperShotgun =
{
	local vector dir;

	if ((self.currentammo == 1))
	{
		W_FireShotgun ();
		return;
	}
	EjectShell ();
	EjectShell ();
	sound (self, 1, "weapons/shotgn2.wav", 1, 1);
	KickPlayer (-4.000000, self);
	self.ammo_shells = (self.ammo_shells - 2);
	self.currentammo = (self.ammo_shells);
	dir = aim (self, 100000);
	deathmsg = 2;
	FireBullets (14, dir, '0.14 0.08 0');
};

void (vector _p_2685, float _p_2688) FireSniperBullet =
{
	local vector _l_2689;
	local vector _l_2692;

	makevectors (self.v_angle);
	_l_2692 = self.origin + (v_forward * 10);
	_l_2692_z = self.absmin_z + (self.size_z * 0.700000);
	ClearMultiDamage ();
	traceline (_l_2692, (_l_2692 + (_p_2685 * 4096)), 0, self);
	if ((trace_fraction != 1))
	{
		TraceAttack (_p_2688, _p_2685);
	}
	if (trace_ent.takedamage)
	{
		_l_2689 = trace_endpos - (v_forward * 4);
		SpawnBlood (_l_2689, 9);
	}
	else
	{
		_l_2689 = trace_endpos - (v_forward * 4);
		WriteByte (4, 23);
		WriteByte (4, 0);
		WriteCoord (4, _l_2689_x);
		WriteCoord (4, _l_2689_y);
		WriteCoord (4, _l_2689_z);
		multicast (self.origin, 1);
	}
	ApplyMultiDamage ();
};

void () W_FireSniperRifle =
{
	local vector dir;
	local vector _l_2708;
	local vector src;
	local float dam_mult;
	local float zdif;
	local float use_this;
	local float x;
	local vector f;
	local vector g;
	local vector h;
#ifdef clan_progs
	local float damg;	//PZ - damg is for Randomer's charge-up fix
#endif

	sound (self, 1, "weapons/rifle.wav", 1, 1);
	self.ammo_shells = (self.ammo_shells - 1);
	KickPlayer (-2.000000, self);
	self.currentammo = (self.ammo_shells - 1);
	EjectShell ();
	makevectors (self.v_angle);
	src = (self.origin + (v_forward * 10));
	src_z = (self.absmin_z + (self.size_z * 0.7));
	use_this = 0.000000;
	traceline (src, (src + (dir * 8092)), 0.000000, self);
	if ((trace_fraction != 1))
	{
		if ((trace_ent.classname == "player"))
		{
			use_this = 1;
		}
	}
	KickPlayer (-4.000000, self);
	if (!use_this)
	{
		dir = aim (self, 10000);
		traceline (src, (src + (dir * 3072)), 0.000000, self);
	}
	deathmsg = 18;
	dam_mult = 1;
#ifdef clan_progs
	// PZ - code added for randomer's charge-up fix
	damg = (time - self.heat) / #WEAP_SNIPER_RIFLE_MAX_TIME;
	if (damg < 0)
		damg = 0;
	if (damg > 1)
		damg = 1;
	damg = damg * (#WEAP_SNIPER_RIFLE_MAX_DAMG - #WEAP_SNIPER_RIFLE_MIN_DAMG) + #WEAP_SNIPER_RIFLE_MIN_DAMG; // Powerup * damage range + minimum damage.
#endif
	if (trace_ent)
	{
		if ((trace_ent.classname == "player"))
		{
			f = (trace_endpos - src);
			g_x = trace_endpos_x;
			g_y = trace_endpos_y;
			g_z = 0.000000;
			h_x = trace_ent.origin_x;
			h_y = trace_ent.origin_y;
			h_z = 0.000000;
			x = vlen ((g - h));
			f = ((normalize (f) * x) + trace_endpos);
			zdif = (f_z - trace_ent.origin_z);
			deathmsg = 18;
			trace_ent.head_shot_vector = '0 0 0';
			if (((zdif < 0) && (trace_ent.is_squating == 0)))
			{
				dam_mult = 0.5;
				if ((trace_ent.team_no != self.team_no))
				{
					trace_ent.leg_damage = (trace_ent.leg_damage + 1);
					TeamFortress_SetSpeed (trace_ent);
					deathmsg = 28;
#ifdef clan_progs
					T_Damage (trace_ent, self, self, (damg * dam_mult));
#else
					T_Damage (trace_ent, self, self, (self.heat * dam_mult));
#endif
				}
				if ((trace_ent.health > 0))
				{
					if ((trace_ent.team_no == self.team_no))
					{
						sprint (self, 1, "Stop shooting team mates!!!\n");
					}
					else
					{
						sprint (trace_ent, 1, "Leg injury!\n");
						sprint (self, 1, "Leg shot - that'll slow him down!\n");
					}
				}
				return;
			}
			else
			{
				if (((zdif > 20) || (trace_ent.is_squating == 1)))
				{
					dam_mult = 3;
					stuffcmd (trace_ent, "bf\n");
					deathmsg = 29;
					if ((trace_ent.health > 0))
					{
						if ((trace_ent.team_no == self.team_no))
						{
							sprint (self, 1, "Stop shooting team mates!!!\n");
						}
						else
						{
							trace_ent.head_shot_vector = (trace_ent.origin - self.origin);
							deathmsg = 29;
#ifdef clan_progs
							T_Damage (trace_ent, self, self, (damg * dam_mult));
#else
							T_Damage (trace_ent, self, self, (self.heat * dam_mult));
#endif
							sound (self, 0, "speech/excelent.wav", 1, 0);
						}
						return;
					}
					else
					{
						deathmsg = 18;
					}
				}
			}
		}
		ClearMultiDamage ();
		if ((trace_fraction != 1))
		{
#ifdef clan_progs
			TraceAttack ((damg * dam_mult), dir);
#else
			TraceAttack ((self.heat * dam_mult), dir);
#endif
		}
		ApplyMultiDamage ();
	}
	else
	{
		_l_2708 = trace_endpos - (v_forward * 4);
		WriteByte (4, 23);
		WriteByte (4, 0);
		WriteCoord (4, _l_2708_x);
		WriteCoord (4, _l_2708_y);
		WriteCoord (4, _l_2708_z);
		multicast (self.origin, 1);
	}
};

void () W_FireAutoRifle =
{
	local vector dir;

	sound (self, 1, "weapons/rifle.wav", 1, 1);
	KickPlayer (-1.000000, self);
	self.ammo_shells = (self.ammo_shells - 1);
	self.currentammo = (self.ammo_shells);
	makevectors (self.v_angle);
	dir = v_forward;
	deathmsg = 19;
	FireSniperBullet (dir, 10);
};

void () W_FireAssaultCannon =
{
	local vector dir;

	KickPlayer (-4.000000, self);
	self.ammo_shells = (self.ammo_shells - 1);
	self.currentammo = (self.ammo_shells);
	dir = aim (self, 100000);
	deathmsg = 20;
	FireBullets (6, dir, '0.04 0.04 0');
	Stats_Fired (self.current_weapon);
};

void () T_MissileTouch =
{
	local float damg;

	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
/*	if (((other.playerclass == 7) && (other.team_no != self.team_no)))
	{
		deflect = hwguy_deflect (other);
		if (deflect)
		{
			return;
		}
	}*/
	damg = (92 + (random () * 20));
	deathmsg = self.weapon;
	if (other.health)
	{
		TF_T_Damage (other, self, self.owner, damg, 0.000000, 4);
	}
	T_RadiusDamage (self, self.owner, 92, other);
	self.origin = (self.origin - (8 * normalize (self.velocity)));
	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);
	multicast (self.origin, 1);
	BecomeExplosion ();
	dremove (self);
};

void () RemoveAlarmMine =
{
	sprint (self.owner, 2, "Your batteries died in an alarm.. :(\n");
	dremove (self);
	return;
};

void () RemoveAIDSMine =
{
	sprint (self.owner, 2, "Your syringe is sterile...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};

void () RemoveFlashMine =
{
	sprint (self.owner, 2, "Your Flash mine fizzled...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};

void () RemoveSpikeTrap =
{
	sprint (self.owner, 2, "Your Spike Trap is gone...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};

void () RemoveMagnetMine =
{
	sprint (self.owner, 2, "Your Mag Mine is gone...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};

void () AlarmMineTouch =
{

	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if ((other.bugger > 0.000000))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		if ((((other.velocity_x < 5.000000) && (other.velocity_y < 5.000000)) && (other.is_squating == 1.000000)))
		{
			self.think = RemoveAlarmMine;
			self.nextthink = (time + 0.200000);
		}
		else
		{
			return;
		}
	}
	else
	{
		other.effects = (other.effects | 4.000000);
		sound (self, 3.000000, "misc/enemy.wav", 1.000000, 1.000000);
		sprint (other, 2.000000, "You have tripped an ALARM!\n");
		sprint (self.owner, 2.000000, "Your ALARM was tripped!\n");
		sprint (self.owner, 2.000000, "        Your ALARM was tripped!\n");
		self.pausetime = (time + 5.000000);
	}
	self.nextthink = (time + 10.000000);
	if ((other.effects & 4.000000))
	{
		other.effects = (other.effects - (other.effects & 8.000000));
	}
};

void () AIDSMineTouch =
{
	local entity BioInfection;

	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= TF_FLARE_LIT))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if ((other.playerclass == 5))
	{
		RemoveAIDSMine ();
		sprint (other, 2, "You removed an enemy syringe! :)\n");
		sprint (self.owner, 2, " Syringe removed by enemy medic!\n");
		return;
	}
	if ((other.classname == "player"))
	{
		deathmsg = 14;
		if ((other.playerclass == 5))
		{
			return;
		}
		other.tfstate = (other.tfstate | 16);
		BioInfection = spawn ();
		BioInfection.classname = "timer";
		BioInfection.owner = other;
		BioInfection.nextthink = (time + 2);
		BioInfection.think = BioInfection_Decay;
		BioInfection.enemy = self.owner;
		other.infection_team_no = self.team_no;
	}
	sound (self, 3, "player/mpain6.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	sprint (other, 2, "You're infected by a syringe! :(\n");
	sprint (self.owner, 2, "Your syringe has Infected an enemy!\n");
	bprint (1, other.netname);
	bprint (1, " was infected by ");
	bprint (1, self.owner.netname);
	bprint (1, "'s syringe\n");
	self.pausetime = (time + 5);
	self.nextthink = (time + 10);
	RemoveAIDSMine ();
};

void () FlashMineTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= TF_FLARE_LIT))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if ((other.classname == "player"))
	{
	
		FlashGrenadeExplode2 ();
		sprint (self.owner, 2, "Your Flash mine was tripped!\n");
		//self.pausetime = (time + 5);
	}
	//self.nextthink = (time+ 1);
	self.nextthink = time;
	dremove (self);
};

void () SpikeTrapTouch =
{

	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if ((other.invincible_finished >= time))
	{
		if ((other.invincible_sound < time))
		{
			sound (other, 3.000000, "items/protect3.wav", 1.000000, 1.000000);
			other.invincible_sound = (time + 2.000000);
		}
		return;
	}
	if ((other.bugger > 0.000000))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if ((other.playerclass == 6.000000))
	{
		RemoveSpikeTrap ();
		sprint (other, 2.000000, "You removed an enemy trap!\n");
		sprint (self.owner, 2.000000, "Spike Trap removed by enemy!\n");
		sound (self, 3.000000, "weapons/tink2.wav", 1.000000, 1.000000);
		return;
	}
	sound (self, 3.000000, "shambler/smack.wav", 1.000000, 1.000000);
	sprint (other, 2.000000, "You stepped on a Spike Trap!\n");
	sprint (self.owner, 2.000000, "Your Trap worked!\n");
	self.pausetime = (time + 5.000000);
	self.nextthink = (time + 5.000000);
	deathmsg = 200.000000;
	TF_T_Damage (other, self.owner, self.owner, 1.000000, 2.000000, 0.000000);
	if ((other.health <= 0.000000))
	{
		return;
	}
	other.leg_damage = (other.leg_damage + 1.000000);
	TeamFortress_SetSpeed (other);
};

void () MagnetMineTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= TF_FLARE_LIT))
	{
		return;
	}
	if ((other.is_undercover == TF_FLARE_OFF))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if ((other.classname == "player"))
	{
		MagMineActivate ();
		sprint (other, 2, "You stepped on a Magnetic Mine! :(\n");
		sprint (self.owner, 2, "Your Magnet Mine worked!\n");
		self.pausetime = (time + 5);
	}
	self.nextthink = (time + 5);
	dremove (self);
};
void () Tranq_spike_touch;
void () spike_touch;
void () superspike_touch;

void (vector org,vector dir) launch_spike =
{

	newmis = spawn ();
	newmis.owner = self;
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.angles = vectoangles (dir);
	newmis.touch = spike_touch;
	newmis.weapon = 3;
	newmis.classname = "spike";
	newmis.think = SUB_Remove;
	newmis.nextthink = (time + 3);
	if ((deathmsg != 9))
	{
		setmodel (newmis, "progs/spike.mdl");
	}
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = (dir * 2000);
};

void (vector org,vector dir) Tranq_launch_spike =
{

	newmis = spawn ();
	newmis.owner = self;
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.angles = vectoangles (dir);
	newmis.touch = Tranq_spike_touch;
	newmis.weapon = 3;
	newmis.classname = "spike";
	newmis.think = SUB_Remove;
	newmis.nextthink = (time + 3);
	if ((deathmsg != 25))
	{
		setmodel (newmis, "progs/spike.mdl");
	}
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = (dir * 2000);
};

void (float type) ThrowMine =
{
	local entity item;

	item = spawn ();
	item.team_no = self.team_no;
	item.owner = self;
	item.classname = "drop1";
	item.origin = (self.origin - '0.000000 0.000000 10.000000');
	if ((type == 1.000000))
	{
		item.angles_x = 270.000000;
	}
	if ((type == 2.000000))
	{
		item.angles_x = 0.000000;
		item.health = 5.000000;
		item.th_die = RemoveAIDSMine;
	}
	if ((type == 4.000000))
	{
		item.angles_x = 90.000000;
		item.health = 5.000000;
		item.th_die = RemoveSpikeTrap;
	}
	item.angles_y = 45.000000;
	item.flags = 256.000000;
	item.solid = 2.000000;
	item.movetype = 6.000000;
	item.velocity = '0.000000 0.000000 1.000000';
	setsize (item, '-1.000000 -1.000000 0.000000', '1.000000 1.000000 6.000000');
	if ((type == 4.000000))
	{
		setmodel (item, "progs/spikebal.mdl");
	}
	else
	{
		if ((type == 5.000000))
		{
			setmodel (item, "progs/tgib1.mdl");
			item.skin = 1.000000;
		}
		else
		{
			setmodel (item, "progs/syringe.mdl");
		}
	}
	if ((type == 1.000000))
	{
		item.touch = AlarmMineTouch;
	}
	if ((type == 2.000000))
	{
		item.touch = AIDSMineTouch;
	}
	if ((type == 3.000000))
	{
		item.health = 1.000000;
		item.th_die = RemoveFlashMine;
		item.touch = FlashMineTouch;
		setmodel (item, "progs/s_bubble.spr");
	}
	if ((type == 4.000000))
	{
		item.touch = SpikeTrapTouch;
	}
	if ((type == 5.000000))
	{
		item.touch = MagnetMineTouch;
		setmodel (item, "progs/tgib1.mdl");
	}
	item.nextthink = (time + 180.000000);
	if ((type == 1.000000))
	{
		item.think = RemoveAlarmMine;
	}
	if ((type == 2.000000))
	{
		item.think = RemoveAIDSMine;
	}
	if ((type == 3.000000))
	{
		item.think = RemoveFlashMine;
	}
	if ((type == 4.000000))
	{
		item.think = RemoveSpikeTrap;
	}
	if ((type == 5.000000))
	{
		item.think = RemoveMagnetMine;
	}
};

void () A_Mine =
{
	if (((self.ammo_cells < 50) && (self.playerclass == 2)))
	{
		sprint (self, 2, "Not enough cells...\n");
		return;
	}
//	if (((self.ammo_cells < 200) && (self.playerclass == 9)))
//	{
//		sprint (self, 2, "Not enough cells...\n");
//		return;
//	}
	self.ammo_cells = TF_FLARE_LIT;
	ThrowMine (1);
	sprint (self, 2, "You set an alarm!\n");
	sound (self, 2, "effects/beep.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};

void () B_Mine =
{
	local entity te;

	if ((self.has_syringe != 1))
	{
		sprint (self, 2, "1 syringe at a time!\n");
		return;
	}
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			sprint (self, 2, "1 syringe at a time!\n");
			return;
		}
		te = find (te, classname, "drop1");
	}

	ThrowMine (2);
	sprint (self, 2, "You dropped a syringe!\n");
	sound (self, 2, "weapons/tink1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};

void () C_Mine =
{
	local entity te;

	if ((self.has_syringe != 1))
	{
		sprint (self, 2, "1 flash mine at a time!\n");
		return;
	}
	if ((self.last_used >= time))
	{
		sprint (self, 2, "not ready yet...\n");
		return;
	}
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			sprint (self, 2, "1 flash mine at a time!\n");
			return;
		}
		te = find (te, classname, "drop1");
	}

	ThrowMine (3);
	sprint (self, 2, "You set a Flash mine!\n");
	sound (self, 2, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};

void () S_Mine =
{
	local entity te;
	local float spikecount;

	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			spikecount = (spikecount + TF_FLARE_OFF);
		}
		te = find (te, classname, "drop1");
	}
	if ((spikecount >= 2))
	{
		sprint (self, 2, "2 spike traps at a time!\n");
		return;
	}
	ThrowMine (4);
	sprint (self, 2, "You set a Spike Trap!\n");
	sound (self, 2, "doors/meduse.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};

void () M_Mine =
{
	local entity te;

	if ((self.has_syringe != 1.000000))
	{
		sprint (self, 2.000000, "You get 1 Mag Mine at a time!\n");
		return;
	}
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			sprint (self, 2.000000, "You get 1 Mag Mine at a time!\n");
			return;
		}
		te = find (te, classname, "drop1");
	}
	ThrowMine (5.000000);
	sprint (self, 2.000000, "You set a Mag Mine!\n");
	sound (self, 2.000000, "weapons/bounce.wav", 1.000000, 1.000000);
};

void () MakeHolo =
{
	local string he;
	he = infokey(self, "tf_help");

	if ((self.playerclass == TF_FLARE_LIT))
	{
		return;
	}
	if ((self.has_holo != 1))
	{
		if (he != "off")
		{
			sprint (self, 2, "holograph already running!\n");
			return;
		}
		else
		{
			return;
		}
	}
	self.has_holo = 0.000000;
	HoloDood ();
	if (he != "off")
	{
		sprint (self, 2, "Holographic replica active!\n");
	}
};

void () W_FireRocket =
{
	self.ammo_rockets = (self.ammo_rockets - 1);
	self.currentammo = (self.ammo_rockets);
	sound (self, 1, "weapons/sgun1.wav", 1, 1);
	KickPlayer (-2.000000, self);
	newmis = spawn ();
	newmis.owner = self;
	newmis.team_no = self.team_no;
	newmis.movetype = 9;
	newmis.solid = 2;
	makevectors (self.v_angle);
	newmis.velocity = v_forward;
	newmis.velocity = (newmis.velocity * 1350);			// pablo. rocket speed. mtf 1350. reg 900.
	newmis.angles = vectoangles (newmis.velocity);
	newmis.touch = T_MissileTouch;
	newmis.nextthink = (time + 5);
	newmis.think = SUB_Remove;
	newmis.weapon = 6;
	setmodel (newmis, "progs/missile.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, ((self.origin + (v_forward * 8)) + '0 0 16'));  //setorigin (newmis, ((self.origin + (v_forward * 8)) + '0 0 16'));
};

void () BalloonMIRVtouch =
{
	if ((pointcontents (self.origin) == -6.000000))
	{
		self.velocity_z = TF_FLARE_LIT;
	}
	if ((pointcontents (self.origin) == -2.000000))
	{
		self.velocity = '0 0 0';
	}
};

void (vector org,entity shooter) BalloonMirvGrenadeLaunch =
{
	local float xdir;
	local float ydir;
	local float zdir;

	xdir = ((150 * random ()) - 75);
	ydir = ((150 * random ()) - 75);
	zdir = (40 * random ());
	newmis = spawn ();
	newmis.owner = shooter;
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "grenade";
	newmis.weapon = 40;
	newmis.touch = GrenadeTouch;
	newmis.think = GrenadeExplode;
	newmis.nextthink = ((time + 2) + (random () * 2));
	newmis.velocity_x = (xdir * 2);
	newmis.velocity_y = (ydir * 2);
	newmis.velocity_z = (zdir * 10);
	newmis.avelocity = '0 0 0';
	setmodel (newmis, "progs/hgren2.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
};

void () BalloonMIRVpop =
{
	local float i;

	sound (self, 3, "shambler/sboom.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	deathmsg = 40;
	i = TF_FLARE_LIT;
	while ((i < 6))
	{
		BalloonMirvGrenadeLaunch ((self.origin + '0 0 -1'), self.owner);
		i = (i + TF_FLARE_OFF);
	}
	BecomeExplosion ();
};

void () BalloonMIRVnoise =
{
	self.playerclass = (self.playerclass + TF_FLARE_OFF);
	self.nextthink = (time + 0.3);
	if (((self.velocity_x < 3) && (self.velocity_y < 3)))
	{
		sound (self, 0.000000, "player/axhit2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	else
	{
		sound (self, 0.000000, "weapons/throw.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	if ((self.playerclass >= 20))
	{
		self.think = BalloonMIRVpop;
	}
};

void () BalloonMIRV =
{
	if ((self.no_grenades_2 < TF_FLARE_OFF))
	{
		sprint (self, 2, "You need type 2 grens for an AirMIRV\n");
		return;
	}
	if ((self.last_saveme_sound > time))
	{
		return;
	}
	self.last_saveme_sound = (time + 2);
	self.no_grenades_2 = (self.no_grenades_2 - TF_FLARE_OFF);
	sprint (self, 2, "AirMIRV released!\n");
	sound (self, 3, "weapons/chngnu1a.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis = spawn ();
	newmis.health = 180;
	newmis.takedamage = 2;
	newmis.th_die = BalloonMIRVpop;
	newmis.owner = self;
	newmis.weapon = 40;
	newmis.movetype = 5;
	newmis.solid = 2;//TF_FLARE_OFF;
	newmis.classname = "bot";//"grenade";
	// pablo. netname so i can fudge gun's aim.
	newmis.netname = "airmirv";
	//
	newmis.playerclass = TF_FLARE_LIT;
	newmis.team_no = self.team_no; // can't shotgun your own airmirvs anyway.
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = ((v_forward * 100) + (v_up * 200));
	}
	else
	{
		newmis.velocity = aim (self, 10000);
		newmis.velocity = (newmis.velocity * 100);
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '0 0 0';
	setsize (newmis, '-8 -8 -8', '8 8 8');
	setorigin (newmis, self.origin);
	newmis.nextthink = (time + TF_FLARE_OFF);
	newmis.think = BalloonMIRVnoise;
	newmis.touch = BalloonMIRVtouch;
	setmodel (newmis, "progs/air-mirv.mdl");
	deathmsg = 40;
};

void (entity from,float damage) LightningHit =
{
	WriteByte (4, 23);
	WriteByte (4, 13);
	WriteCoord (4, trace_endpos_x);
	WriteCoord (4, trace_endpos_y);
	WriteCoord (4, trace_endpos_z);
	multicast (trace_endpos, 2);
	TF_T_Damage (trace_ent, from, from, damage, 2, 8);
};

void (vector p1,vector p2,entity from,float damage) LightningDamage =
{
	local entity e1;
	local entity e2;
	local vector f;

	f = (p2 - p1);
	normalize (f);
	f_x = (0.000000 - f_y);
	f_y = f_x;
	f_z = 0.000000;
	f = (f * 16);
	e2 = world;
	e1 = world;
	traceline (p1, p2, 0.000000, self);
	if (trace_ent.takedamage)
	{
		LightningHit (from, damage);
		if ((self.classname == "player"))
		{
			if ((other.classname == "player"))
			{
				trace_ent.velocity_z = (trace_ent.velocity_z + 400);
			}
		}
	}
	e1 = trace_ent;
	traceline ((p1 + f), (p2 + f), 0.000000, self);
	if (((trace_ent != e1) && trace_ent.takedamage))
	{
		LightningHit (from, damage);
	}
	e2 = trace_ent;
	traceline ((p1 - f), (p2 - f), 0.000000, self);
	if ((((trace_ent != e1) && (trace_ent != e2)) && trace_ent.takedamage))
	{
		LightningHit (from, damage);
	}
};

void () W_FireLightning =
{
	local vector org;
	local float cells;

	if ((self.ammo_cells < 1))
	{
		self.current_weapon = W_BestWeapon ();
		W_SetCurrentAmmo ();
		W_PrintWeaponMessage ();
		return;
	}
	if ((self.waterlevel > 1))
	{
		cells = self.ammo_cells;
		self.ammo_cells = 0.000000;
		W_SetCurrentAmmo ();
		deathmsg = 7;
		T_RadiusDamage (self, self, (35 * cells), world);
		return;
	}
	if ((self.t_width < time))
	{
		sound (self, 1, "weapons/lhit.wav", 1, 1);
		self.t_width = (time + 0.6);
	}
	KickPlayer (-2.000000, self);
	self.ammo_cells = (self.ammo_cells - 1);
	self.currentammo = (self.ammo_cells);
	org = (self.origin + '0 0 16');
	traceline (org, (org + (v_forward * 600)), 1, self);
	WriteByte (4, 23);
	WriteByte (4, 6);
	WriteEntity (4, self);
	WriteCoord (4, org_x);
	WriteCoord (4, org_y);
	WriteCoord (4, org_z);
	WriteCoord (4, trace_endpos_x);
	WriteCoord (4, trace_endpos_y);
	WriteCoord (4, trace_endpos_z);
	multicast (org, 1);
	LightningDamage (self.origin, (trace_endpos + (v_forward * 4)), self, 30);
};
/* gold. bye bye, useless coding
void () W_FireSuperSpikes =
{
	local vector dir;
	local entity old;

	sound (self, 1, "weapons/spike2.wav", 1, 1);
	Attack_Finished (0.2);
	self.ammo_nails = (self.ammo_nails - 2);
	self.currentammo = (self.ammo_nails);
	dir = aim (self, 1000);
	launch_spike ((self.origin + '0 0 16'), dir);
	newmis.touch = superspike_touch;
	newmis.weapon = 4;
	setmodel (newmis, "progs/s_spike.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	KickPlayer (-2.000000, self);
};
*/
void () W_FireSpikes =
{
	local vector dir;

	makevectors (self.v_angle);
	Stats_Fired (self.current_weapon);
	//if (((self.ammo_nails >= 2) && (self.current_weapon == 1024)))
	if (((self.ammo_nails >= 1) && (self.current_weapon == 1024)))
	{
		sound (self, 1, "effects/mortar.wav", 1, 1);
		deathmsg = 4;
		Attack_Finished (0.3);
		self.ammo_nails = (self.ammo_nails - 2);
		self.currentammo = (self.ammo_nails - 1);
		dir = aim (self, 1000);
		FireSniperBullet (dir, 10);
		KickPlayer (-4.000000, self);
		return;
	}
	if ((self.ammo_nails < 1))
	{
		self.current_weapon = W_BestWeapon ();
		W_SetCurrentAmmo ();
		W_PrintWeaponMessage ();
		return;
	}
	sound (self, 3, "weapons/sniper.wav", 1, 1);
	Attack_Finished (0.1);
	self.ammo_nails = (self.ammo_nails - 1);
	self.currentammo = (self.ammo_nails - 1);
	dir = aim (self, 1000);
	deathmsg = 3;
	FireSniperBullet (dir, 4);
};
//.float hit_z;

void () spike_touch =
{

	if ((other.solid == 1))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (other.takedamage)
	{
		spawn_touchblood (9);
		deathmsg = self.weapon;
		if ((self.owner.classname == "grenade"))
		{
			TF_T_Damage (other, self, self.owner.owner, 9, 2, 2);
		}
		else
		{
			TF_T_Damage (other, self, self.owner, 9, 2, 2);
		}
	}
	else
	{
		WriteByte (4, 23);
		if ((self.classname == "wizspike"))
		{
			WriteByte (4, 7);
		}
		else
		{
			if ((self.classname == "knightspike"))
			{
				WriteByte (4, 8);
			}
			else
			{
				WriteByte (4, 0.000000);
			}
		}
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
		multicast (self.origin, 1);
	}
	dremove (self);
};

void () Tranq_spike_touch =
{
	if ((other.solid == 1))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (other.takedamage)
	{
		spawn_touchblood (9);
		deathmsg = 25;
		if ((self.owner.classname == "Tgrenade"))
		{
			TF_T_Damage (other, self, self.owner.owner, 9, 2, 2);
		}
		else
		{
			TF_T_Damage (other, self, self.owner, 9, 2, 2);
		}
	}
	else
	{
		WriteByte (4, 23);
		if ((self.classname == "wizspike"))
		{
			WriteByte (4, 7);
		}
		else
		{
			if ((self.classname == "knightspike"))
			{
				WriteByte (4, 8);
			}
			else
			{
				WriteByte (4, 0.000000);
			}
		}
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
		multicast (self.origin, 1);
	}
	dremove (self);
};

void () superspike_touch =
{
	local float ndmg;

	if ((other == self.owner))
	{
		return;
	}
	if ((other.solid == 1))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (other.takedamage)
	{
		spawn_touchblood (18);
		deathmsg = self.weapon;
		if ((deathmsg == 9))
		{
			ndmg = 40;
		}
		else
		{
			ndmg = 13;
		}
		if ((self.owner.classname == "grenade"))
		{
			TF_T_Damage (other, self, self.owner.owner, ndmg, 2, 2);
		}
		else
		{
			TF_T_Damage (other, self, self.owner, ndmg, 2, 2);
		}
	}
	else
	{
		WriteByte (4, 23);
		WriteByte (4, 1);
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
		multicast (self.origin, 1);
	}
	dremove (self);
};

// xavior's fix for reload after proxy is selected
void (entity reloaded_player, float type_rl) W_ReloadSetCurrentAmmo =
{
	if (type_rl == 0)
	{
		reloaded_player.items = (reloaded_player.items - (reloaded_player.items & (((256 | 512) | 1024) | 2048)));
		reloaded_player.currentammo = 0;
	}
 	else if (type_rl == 1)
	{
		reloaded_player.currentammo = reloaded_player.ammo_shells;
		reloaded_player.items = (reloaded_player.items | 2048);
	}
	else
	{
		reloaded_player.currentammo = reloaded_player.ammo_rockets;
		reloaded_player.items = (reloaded_player.items | 1024);
	}
}

void () W_SetCurrentAmmo =
{

	if (((self.health <= 0.000000) || (self.current_weapon == 0.000000)))
	{
		return;
	}
	if ((self.weaponmodel == "progs/proxgren.mdl"))
	{
		self.currentammo = self.currentammo;
		return;
	}
//	player_run ();
	self.items = (self.items - (self.items & (((256 | 512) | 1024) | 2048)));
	self.weapon = 0.000000;         // pablo. fix to assualt cannon jamming when on backpacks.
	if ((self.tools == (self.tools | 32)))
	{
		return;
	}
	if ((self.current_weapon == 16))
	{
		self.currentammo = 0.000000;
		if ((self.weaponmode == 0.000000))
		{
			self.weaponmodel = "progs/v_knife.mdl";//v_axe.mdl";
		}
		else
		{
			self.weaponmodel = "progs/v_knife2.mdl";//self.weaponmodel = "progs/v_axe.mdl";
		}
		self.weaponframe = 0.000000;
	}
	else
	{
		if ((self.current_weapon == 1))
		{
			if ((self.owner.ammo_cells > 0))
			{
				self.ammo_cells = self.owner.ammo_cells;
			}
			self.currentammo = self.ammo_cells;
			self.weaponmodel = "progs/v_grap.mdl";
			self.weaponframe = 0.000000;
		}
		else
		{
			if ((self.current_weapon == 8))
			{
				self.currentammo = self.ammo_cells;
				self.weaponmodel = "progs/v_span.mdl";
				self.weaponframe = 0.000000;
			}
			else
			{
				if ((self.current_weapon == 128))
				{
					self.currentammo = self.ammo_shells;
					self.items = (self.items | 2048);
					if (!(self.tfstate & 2))
					{
						self.weaponmodel = "progs/v_shot.mdl";
						self.weaponframe = 0.000000;
					}
					self.items = (self.items | 256);
					self.weapon = 1;
				}
				else
				{
					if ((self.current_weapon == 256))
					{
						self.currentammo = self.ammo_shells;
						if (!(self.tfstate & 2))
						{
							self.weaponmodel = "progs/v_shot2.mdl";
							self.weaponframe = 0.000000;
						}
						self.items = (self.items | 256);
						self.weapon = 2;
					}
					else
					{
						if ((self.current_weapon == 512))
						{
							self.currentammo = self.ammo_nails;
							if (!(self.tfstate & 2))
							{
								self.weaponmodel = "progs/v_mac10.mdl";
								self.weaponframe = 0.000000;
							}
							self.items = (self.items | 512);
							self.weapon = 4;
						}
						else
						{
							if ((self.current_weapon == 1024))
							{
								self.currentammo = self.ammo_nails;
								if (!(self.tfstate & 2))
								{
									self.weaponmodel = "progs/v_nail2.mdl";
									self.weaponframe = 0.000000;
								}
								self.items = (self.items | 512);
								self.weapon = 8;
							}
							else
							{
								if ((self.current_weapon == 2048))
								{
									self.currentammo = self.ammo_rockets;
									if (!(self.tfstate & 2))
									{
										self.weaponmodel = "progs/v_rock.mdl";
										self.weaponframe = 0.000000;
									}
									self.weapon = 16;
									self.items = (self.items | 1024);
								}
								else
								{
									if ((self.current_weapon == 8192))
									{
										self.currentammo = self.ammo_rockets;
										if (!(self.tfstate & 2))
										{
											self.weaponmodel = "progs/v_rock2.mdl";
											self.weaponframe = 0.000000;
										}
										self.items = (self.items | 1024);
										self.weapon = 32;
									}
									else
									{
										if ((self.current_weapon == 65536))
										{
											self.currentammo = self.ammo_cells;
											if (!(self.tfstate & 2))
											{
												self.weaponmodel = "progs/v_light.mdl";
												self.weaponframe = 0.000000;
											}
											self.items = (self.items | 2048);
											self.weapon = 64;
										}
										else
										{
											if ((self.current_weapon == 32))
											{
												self.currentammo = self.ammo_shells;
												if (!(self.tfstate & 2))
												{
													self.weaponmodel = "progs/v_srifle.mdl";
													self.weaponframe = 0.000000;
												}
												self.items = (self.items | 256);
												self.weapon = 1;
											}
											else
											{
												if ((self.current_weapon == 64))
												{
													self.currentammo = self.ammo_shells;
													if (!(self.tfstate & 2))
													{
														self.weaponmodel = "progs/v_srifle.mdl";
														self.weaponframe = 0.000000;
													}
													self.items = (self.items | 256);
													self.weapon = 2;
												}
												else
												{
													if ((self.current_weapon == 32768))
													{
														self.currentammo = self.ammo_shells;
														if (!(self.tfstate & 2))
														{
															self.weaponmodel = "progs/v_asscan.mdl";
															self.weaponframe = 0.000000;
														}
														self.items = (self.items | 256);
														self.weapon = 32;
													}
													else
													{
														if ((self.current_weapon == 4096))
														{
															self.currentammo = self.ammo_cells;
															if (!(self.tfstate & 2))
															{
																self.weaponmodel = "progs/v_rock.mdl";
																self.weaponframe = 0.000000;
															}
															self.items = (self.items | 2048);
															self.weapon = 16;
														}
														else
														{
															if ((self.current_weapon == 16384))
															{
																self.currentammo = self.ammo_rockets;
																if (!(self.tfstate & 2))
																{
																	self.weaponmodel = "progs/v_rock2.mdl";
																	self.weaponframe = 0.000000;
																}
																self.items = (self.items | 1024);
																self.weapon = 32;
															}
															else
															{
																if ((self.current_weapon == 4))
																{
																	self.currentammo = 0.000000;
																	self.weaponmodel = "progs/v_medi.mdl";
																	self.weaponframe = 0.000000;
																}
																else
																{
																	if ((self.current_weapon == 2))
																	{
																		self.currentammo = 0.000000;
																		self.weaponmodel = "progs/v_bio.mdl";
																		self.weaponframe = 0.000000;
																	}
																	else
																	{
																		if ((self.current_weapon == 262144))
																		{
																			self.currentammo = self.ammo_shells;
																			if (!(self.tfstate & 2))
																			{
																				self.weaponmodel = "progs/v_shot.mdl";
																				self.weaponframe = 0.000000;
																			}
																			self.items = (self.items | 256);
																			self.weapon = 1;
																		}
																		else
																		{
																			if ((self.current_weapon == 524288))
																			{
																				self.currentammo = self.ammo_nails;
																				if (!(self.tfstate & 2))
																				{
																					self.weaponmodel = "progs/v_rail.mdl";
																					self.weaponframe = 0.000000;
																				}
																				self.items = (self.items | 512);
																				self.weapon = 1;
																			}
																			else
																			{
																				self.currentammo = 0.000000;
																				self.weaponmodel = "";
																				self.weaponframe = 0.000000;
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};

float () W_BestWeapon =
{
	local float it;

	it = self.weapons_carried;
	if ((((self.ammo_cells >= 1) && (it & 65536)) && (self.waterlevel <= 1)))
	{
		return (65536);
	}
	else
	{
		if ((((self.ammo_cells >= 6) && (self.ammo_shells >= 1)) && (it & 32768)))
		{
			return (32768);
		}
		else
		{
			if (((self.ammo_cells >= 1) && (it & 4096)))
			{
				return (4096);
			}
			else
			{
				if (((self.ammo_nails >= 2) && (it & 1024)))
				{
					return (1024);
				}
				else
				{
					if (((self.ammo_shells >= 2) && (it & 256)))
					{
						return (256);
					}
					else
					{
						if (((self.ammo_nails >= 1) && (it & 524288)))
						{
							return (524288);
						}
						else
						{
							if (((self.ammo_nails >= 1) && (it & 512)))
							{
								return (512);
							}
							else
							{
								if (((self.ammo_shells >= 1) && (it & 128)))
								{
									return (128);
								}
								else
								{
									if (((self.ammo_shells >= 1) && (it & 262144)))
									{
										return (262144);
									}
									else
									{
										if ((it & 4))
										{
											return (4);
										}
										else
										{
											if ((it & 8))
											{
												return (8);
											}
											else
											{
												if ((it & 16))
												{
													return (16);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return (0.000000);
};

float () W_CheckNoAmmo =
{
	if ((self.current_weapon == 4))
	{
		return (1);
	}
	else
	{
		if ((self.current_weapon == 2))
		{
			return (1);
		}
		else
		{
			if ((((self.current_weapon == 16) || (self.current_weapon == 1)) || (self.current_weapon == 8)))
			{
				return (1);
			}
			else
			{
				if (((self.current_weapon == 1) && (self.ammo_cells < 10)))
				{
					return (1);
				}
				else
				{
					if ((self.current_weapon == 16384))
					{
						if ((self.currentammo >= 3))
						{
							return (1);
						}
					}
					else
					{
						if ((self.currentammo > 0.000000))
						{
							return (1);
						}
					}
				}
			}
		}
	}
	self.current_weapon = W_BestWeapon ();
	W_SetCurrentAmmo ();
	W_PrintWeaponMessage ();
	return (0.000000);
};

void () W_Reload_shotgun =
{
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_shot.mdl";
	sound (self.owner, 1, "weapons/pkup.wav", 1, 1);
	sprint (self.owner, 0.000000, "finished reloading\n");
	W_ReloadSetCurrentAmmo (self.owner, 1);
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};

void () W_Reload_super_shotgun =
{
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_shot2.mdl";
	sound (self.owner, 1, "weapons/pkup.wav", 1, 1);
	sprint (self.owner, 0.000000, "finished reloading\n");
	W_ReloadSetCurrentAmmo (self.owner, 1);
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};

void () W_Reload_grenade_launcher =
{
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_rock.mdl";
	sound (self.owner, 1, "weapons/rocklr1a.wav", 1, 1);
	sprint (self.owner, 0.000000, "finished reloading\n");
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};

void () W_Reload_rocket_launcher =
{
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
//	This is my fix for the "proxy reload" bug. Still dunno if I'm gonna keep it in tho.
//			- XavioR
//	if (self.owner.weaponmodel != "progs/proxgren.mdl")
//	{
	self.owner.weaponmodel = "progs/v_rock2.mdl";
	sound (self.owner, 1, "weapons/rocklr1a.wav", 1, 1);
//	}
//	else
//	{
//		self.owner.oldweaponmodel = "progs/v_rock2.mdl";
//	}
	sprint (self.owner, 0.000000, "finished reloading\n");
	W_ReloadSetCurrentAmmo (self.owner, 2); // fixes ammo count after reload while holding
	dremove (self);				// a proxy. - XavioR
	self.owner.StatusRefreshTime = (time + 0.1);
};

float () CheckForReload =
{
	local entity tWeapon;

//	if ((((self.attack_finished > time) || self.button0) || (self.tools == (self.tools | 32))))
//	{
//		return;
//	}
	if ((self.current_weapon == 128))
	{
		if (((self.reload_shotgun >= 8) && (self.ammo_shells > 0.000000)))
		{
			self.reload_shotgun = 0.000000;
			if ((self.ammo_shells < 8))
			{
				self.reload_shotgun = (8 - self.ammo_shells);
			}
			sprint (self, 2, "reloading...\n");
			self.tfstate = (self.tfstate | 2);
			tWeapon = spawn ();
			tWeapon.owner = self;
			tWeapon.classname = "timer";
			tWeapon.nextthink = (time + 2);
			tWeapon.think = W_Reload_shotgun;
			self.weaponmodel = "";
			self.weaponframe = 0.000000;
			return (1);
		}
	}
	else
	{
		if ((self.current_weapon == 256))
		{
			if ((self.reload_super_shotgun > 16))
			{
				self.reload_super_shotgun = 16;
			}
			if (((self.reload_super_shotgun >= 16) && (self.ammo_shells > 0.000000)))
			{
				self.reload_super_shotgun = 0.000000;
				if ((self.ammo_shells < 16))
				{
					self.reload_super_shotgun = (16 - self.ammo_shells);
				}
				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn ();
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = (time + 3);
				tWeapon.think = W_Reload_super_shotgun;
				self.weaponmodel = "";
				self.weaponframe = 0.000000;
				return (1);
			}
		}
		else
		{
			if ((self.current_weapon == 2048))
			{
				if (((self.reload_grenade_launcher >= 6) && (self.ammo_rockets > 0.000000)))
				{
					self.reload_grenade_launcher = 0.000000;
					if ((self.ammo_rockets < 6))
					{
						self.reload_grenade_launcher = (6 - self.ammo_rockets);
					}
					sprint (self, 2, "reloading...\n");
					self.tfstate = (self.tfstate | 2);
					tWeapon = spawn ();
					tWeapon.owner = self;
					tWeapon.classname = "timer";
					tWeapon.nextthink = (time + 4);
					tWeapon.think = W_Reload_grenade_launcher;
					self.weaponmodel = "";
					self.weaponframe = 0.000000;
					return (1);
				}
			}
			else
			{
				if ((self.current_weapon == 8192))
				{
					if (((self.reload_rocket_launcher >= 4) && (self.ammo_rockets > 0.000000)))
					{
						self.reload_rocket_launcher = 0.000000;
						if ((self.ammo_rockets < 4))
						{
							self.reload_rocket_launcher = (4 - self.ammo_rockets);
						}
						sprint (self, 2, "reloading...\n");
						self.tfstate = (self.tfstate | 2);
						tWeapon = spawn ();
						tWeapon.owner = self;
						tWeapon.classname = "timer";
						tWeapon.nextthink = (time + 5);
						tWeapon.think = W_Reload_rocket_launcher;
						self.weaponmodel = "";
						self.weaponframe = 0.000000;
						return (1);
					}
				}
			}
		}
	}
	return (0.000000);
};
void () player_axe1;
void () player_axeb1;
void () player_axec1;
void () player_axed1;
void () player_shot1;
void () player_nail1;
void () player_light1;
void () player_rocket1;
//void () player_tax1;
void () player_autorifle1;
void () player_assaultcannon1;
void () player_assaultcannonup1;
void () player_assaultcannondown1;
void () player_medikit1;
void () player_medikitb1;
void () player_medikitc1;
void () player_medikitd1;
void () player_bioweapon1;
void () player_bioweaponb1;
void () player_bioweaponc1;
void () player_bioweapond1;
void () player_chain1;
void () player_chain2;
void () player_chain3;
void () player_chain4;
void () player_chain5;
//void () W_ThrowAxe;
//void () W_FireTorpedo;

void () W_Attack =
{
	local float r;

	if (((self.playerclass == 0.000000) || (self.team_no <= 0.000000)))
	{
		return;
	}
// pablo. no torpedos in mtf. gg
//	if ((self.tools == (self.tools | 32)))
//	{
//		if ((self.tube_wing > 1))
//		{
//			return;
//		}
//		else
//		{
//			self.attack_finished = (time + 0.5);
//			W_FireTorpedo ();
//			return;
//		}
//	}
	if ((self.weaponmodel == "progs/proxgren.mdl"))
	{
		Prox ();
		Attack_Finished (0.2);//nanenanu
		self.impulse = 0.000000;
		return;
	}
	if (!W_CheckNoAmmo ())
	{
		sound (self, 1, "buttons/switch02.wav", 0.8, 1);
		Attack_Finished (0.05);
		return;
	}
	if ((self.tfstate & 2))
	{
		sound (self, 1, "weapons/no_ammo.wav", 0.8, 1);
		Attack_Finished (0.2);
		return;
	}
	if ((time < self.attack_finished))
	{
		return;
	}
	if (self.is_undercover)
	{
		Spy_RemoveDisguise (self);
	}
	if ((self.is_squating == 1))
	{
		setsize (self, '-16 -16 -24', '16 16 32');
	}
	Stats_Fired (self.current_weapon);
	makevectors (self.v_angle);
	self.show_hostile = (time + 1);
// pablo.
//	if (((self.num_axes == 0.000000) && (self.current_weapon == 16)))
	if (self.current_weapon == 16)
//
	{
		Attack_Finished (0.5);
		sound (self, 1, "weapons/ax1.wav", 1, 1);
		r = random ();
		if ((r < 0.25))
		{
			player_axe1 ();
		}
		else
		{
			if ((r < 0.5))
			{
				player_axeb1 ();
			}
			else
			{
				if ((r < 0.75))
				{
					player_axec1 ();
				}
				else
				{
					player_axed1 ();
				}
			}
		}
	}
	else
	{
// pablo. no throwing axes in mtf.
//		if (((self.num_axes >= 1) && (self.current_weapon == 16)))
//		{
//			player_tax1 ();
//			self.attack_finished = (time + 1);
//		}
//		else
//		{
			if ((self.current_weapon == 8))
			{
				Attack_Finished (0.5);
				sound (self, 1, "weapons/ax1.wav", 1, 1);
				player_axe1 ();
			}
			else
			{
				if ((self.current_weapon == 1))
				{
					if (((!self.hook_out && (self.ammo_cells > 24)) && (self.is_feigning == 0.000000)))
					{
						self.immune_to_check = (time + 4);
						player_chain1 ();
						sound (self, 1, "weapons/sniper.wav", 1, 1);
						sound (self, 3, "weapons/unreel.wav", 1, 1);
						Attack_Finished (0.1);
					}
					else
					{
						sprint (self, 2, "Not enough power cells...\n");
						Attack_Finished (1);
					}
				}
				else
				{
					if ((self.current_weapon == 128))
					{
						if ((CheckForReload () == 1))
						{
							return;
						}
						player_shot1 ();
						W_FireShotgun ();
						self.reload_shotgun = (self.reload_shotgun + 1);
						self.StatusRefreshTime = (time + 0.1);
						CheckForReload ();
						Attack_Finished (0.5);
					}
					else
					{
						if ((self.current_weapon == 256))
						{
							if ((CheckForReload () == 1))
							{
								return;
							}
							player_shot1 ();
							W_FireSuperShotgun ();
							self.reload_super_shotgun = (self.reload_super_shotgun + 2);
							self.StatusRefreshTime = (time + 0.1);
							CheckForReload ();
							Attack_Finished (0.7);
						}
						else
						{
							if ((self.current_weapon == 512))
							{
								player_nail1 ();
							}
							else
							{
								if ((self.current_weapon == 1024))
								{
									player_nail1 ();
								}
								else
								{
									if ((self.current_weapon == 2048))
									{
										if ((CheckForReload () == 1))
										{
											return;
										}
										player_rocket1 ();
										W_FireGrenade ();
										self.reload_grenade_launcher = (self.reload_grenade_launcher + 1);
										if ((self.option == 1))
										{
											self.reload_grenade_launcher = (self.reload_grenade_launcher + 1);
										}
										self.StatusRefreshTime = (time + 0.1);
										CheckForReload ();
										Attack_Finished (0.6);
									}
									else
									{
										if ((self.current_weapon == 8192))
										{
											if ((CheckForReload () == 1))
											{
												return;
											}
											player_rocket1 ();
											W_FireRocket ();
											self.reload_rocket_launcher = (self.reload_rocket_launcher + 1);
											self.StatusRefreshTime = (time + 0.1);
											CheckForReload ();
											Attack_Finished (0.8);
										}
										else
										{
											if ((self.current_weapon == 65536))
											{
												player_light1 ();
												Attack_Finished (0.1);
												sound (self, 0.000000, "weapons/lstart.wav", 1, 1);
											}
										}
									}
								}
							}
						}
					}
				}
//			}
		}
		if ((self.current_weapon == 32))
		{
			if (((self.flags & 512) || self.hook_out))
			{
				player_shot1 ();
				W_FireSniperRifle ();
				Attack_Finished (1.5);
			}
		}
		else
		{
			if ((self.current_weapon == 64))
			{
				player_autorifle1 ();
				W_FireAutoRifle ();
				Attack_Finished (0.1);
			}
			else
			{
				if ((self.current_weapon == 32768))
				{
					if (((self.playerclass == 6) && (self.option4 == 1)))
					{
						W_FireBigAss ();
						Attack_Finished (0.2);
						self.impulse = 0.000000;
						return;
					}
					if ((self.ammo_cells < 4))
					{
						sprint (self, 1, "Insufficient cells to power up the Assault Cannon.\n");
					}
					else
					{
						self.ammo_cells = (self.ammo_cells - 4);
						self.heat = 1;
						self.immune_to_check = (time + 2);
						self.maxspeed = 80;
						self.tfstate = self.tfstate | 131072;
						TeamFortress_SetSpeed(self);
						player_assaultcannonup1 ();
					}
				}
				else
				{
					if ((self.current_weapon == 4096))
					{
						player_shot1 ();
						W_FireFlame ();
						if ((self.waterlevel > 2))
						{
							Attack_Finished (1);
						}
						else
						{
							Attack_Finished (0.15);
						}
					}
					else
					{
						if ((self.current_weapon == 16384))
						{
							player_rocket1 ();
							W_FireIncendiaryCannon ();
							Attack_Finished (1.2);
						}
						else
						{
							if ((self.current_weapon == 4))
							{
								sound (self, 1, "weapons/ax1.wav", 1, 1);
								r = random ();
								if ((r < 0.25))
								{
									player_medikit1 ();
								}
								else
								{
									if ((r < 0.5))
									{
										player_medikitb1 ();
									}
									else
									{
										if ((r < 0.75))
										{
											player_medikitc1 ();
										}
										else
										{
											player_medikitd1 ();
										}
									}
								}
								Attack_Finished (0.5);
							}
							else
							{
								if ((self.current_weapon == 2))
								{
									sound (self, 1, "weapons/ax1.wav", 1, 1);
									r = random ();
									if ((r < 0.25))
									{
										player_bioweapon1 ();
									}
									else
									{
										if ((r < 0.5))
										{
											player_bioweaponb1 ();
										}
										else
										{
											if ((r < 0.75))
											{
												player_bioweaponc1 ();
											}
											else
											{
												player_bioweapond1 ();
											}
										}
									}
									Attack_Finished (0.5);
								}
								else
								{
									if ((self.current_weapon == 262144))
									{
										sound (self, 1, "weapons/dartgun.wav", 1, 1);
										player_shot1 ();
										W_FireTranq ();
										Attack_Finished (1.5);
									}
									else
									{
										if ((self.current_weapon == 524288))
										{
											if ((self.option5 != 1))
											{
												sound (self, 1, "enforcer/enfire.wav", 1, 1);
												player_shot1 ();
												W_FireLaser ();
												Attack_Finished (0.4);
											}/* MegaTF United Super Rail code -- not in MegaTF!
											else
											{
												sound (self, TF_FLARE_OFF, "weapons/railgun.wav", TF_FLARE_OFF, TF_FLARE_OFF);
												player_shot1 ();
												W_FireLaser (self.heat);
												Attack_Finished (1.5);
											}*/
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};

void () W_PrintWeaponMessage =
{
	if (((self.current_weapon == 16) && allow_hook))
	{
		if ((self.playerclass != 8))
		{
			sprint (self, 1, "Knife selected\n");
			self.weaponmode = 3;
		}
	}
	else
	{
		if ((self.current_weapon == 1))
		{
			sprint (self, 1, "grappling hook selected\n");
		}
		else
		{
			if ((self.current_weapon == 2048))
			{
				if (((self.weaponmode == 0.000000) && (self.option != 1)))
				{
					sprint (self, 1, "Normal grenade mode\n");
				}
				else
				{
					if (((self.weaponmode == 0.000000) && (self.option == 1)))
					{
						sprint (self, 1, "Long-range grenade mode\n");
					}
					else
					{
						if (self.weaponmode == 1.000000)
						{
							if (self.option == 0.000000)
							{
								sprint (self, 1.000000, "Pipebomb mode\n");
							}
							else
							{
								sprint (self, 1.000000, "Long-range pipebomb mode\n");
							}
						}
					}
				}
			}
			else
			{
				if ((self.current_weapon == 32))
				{
					sprint (self, 1, "Sniper rifle ready\n");
				}
				else
				{
					if ((self.current_weapon == 64))
					{
						sprint (self, 1, "rifle on fully auto\n");
					}
					else
					{
						if ((self.current_weapon == 262144))
						{
							sprint (self, 1, "Tranquiliser gun selected\n");
						}
						else
						{
							if ((self.current_weapon == 2))
							{
								sprint (self, 1, "BioWeapon readied\n");
							}
							else
							{
								if ((self.current_weapon == 4))
								{
									sprint (self, 1, "Medikit readied\n");
								}
							}
						}
					}
				}
			}
		}
	}
};

void () W_ChangeWeapon =
{
	local float it;
	local float am;
	local float fl;
	local float have_weapon;
	local float usable;

	if ((self.tfstate & 2.000000))
	{
		return;
	}
	if ((self.tools == (self.tools | 32.000000)))
	{
		return;
	}
	it = self.weapons_carried;
	fl = self.current_weapon;
	am = 0.000000;
	usable = 0.000000;
	have_weapon = 1.000000;
	if ((self.playerclass != 8.000000))
	{
		it = it - (it & 1.000000);
	}
	if ((self.impulse == 1.000000))
	{
		if ((fl == 8.000000))
		{
			return;
		}
		if ((((self.playerclass == 5.000000) && (fl == 2.000000)) || (fl == 4.000000)))
		{
			fl = 2.000000;
			return;
		}
		if ((fl != 16.000000))
		{
			if ((self.playerclass != 8.000000))
			{
				sound (self, 1.000000, "weapons/knifedrw.wav", 1.000000, 1.000000);
			}
		}
		while ((!usable && have_weapon))
		{
			if ((fl == 8.000000))
			{
				fl = 2.000000;
				if ((it & 2.000000))
				{
					usable = 1.000000;
				}
			}
			else
			{
				if ((fl == 2.000000))
				{
					fl = 4.000000;
					if ((it & 4.000000))
					{
						usable = 1.000000;
					}
				}
				else
				{
					if ((fl == 4.000000))
					{
						fl = 16.000000;
						usable = 1.000000;
					}
					else
					{
						if ((fl == 1.000000))
						{
							fl = 16.000000;
							usable = 1.000000;
						}
						else
						{
							fl = 8.000000;
							if ((it & 8.000000))
							{
								usable = 1.000000;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		if (((allow_hook && (self.impulse == 22.000000)) || (self.impulse == 39.000000)))
		{
			if ((self.playerclass == 8.000000))
			{
				fl = 1.000000;
			}
			else
			{
				usable = 0.000000;
			}
		}
		else
		{
			if ((self.impulse == 40.000000))
			{
				if (!(it & 30.000000))
				{
					have_weapon = 0.000000;
				}
				while ((!usable && have_weapon))
				{
					if ((fl == 8.000000))
					{
						fl = 2.000000;
						if ((it & 2.000000))
						{
							usable = 1.000000;
						}
					}
					else
					{
						if ((fl == 2.000000))
						{
							fl = 16.000000;
							if ((it & 16.000000))
							{
								usable = 1.000000;
							}
						}
						else
						{
							fl = 8.000000;
							if ((it & 8.000000))
							{
								usable = 1.000000;
							}
						}
					}
				}
			}
			else
			{
				if ((self.impulse == 2.000000))
				{
					if ((it & 32.000000))
					{
						fl = 32.000000;
						if ((self.ammo_shells < 1.000000))
						{
							am = 1.000000;
						}
						else
						{
							sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
						}
					}
					else
					{
						if ((it & 128.000000))
						{
							fl = 128.000000;
							if ((self.ammo_shells < 1.000000))
							{
								am = 1.000000;
							}
							else
							{
								if ((self.playerclass != 8.000000))
								{
									sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
								}
							}
						}
						else
						{
							if ((it & 262144.000000))
							{
								fl = 262144.000000;
								if ((self.ammo_shells < 1.000000))
								{
									am = 1.000000;
								}
								else
								{
									if ((self.playerclass != 8.000000))
									{
										sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
									}
								}
							}
							else
							{
								if ((it & 524288.000000))
								{
									fl = 524288.000000;
									if ((self.ammo_nails < 1.000000))
									{
										am = 1.000000;
									}
									else
									{
										sound (self, 1.000000, "weapons/railgr1a.wav", 0.800000, 1.000000);
									}
								}
								else
								{
									have_weapon = 0.000000;
								}
							}
						}
					}
				}
				else
				{
					if ((self.impulse == 3.000000))
					{
						if ((it & 64.000000))
						{
							fl = 64.000000;
							if ((self.ammo_shells < 1.000000))
							{
								am = 1.000000;
							}
							else
							{
								if ((self.playerclass != 8.000000))
								{
									sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
								}
							}
						}
						else
						{
							fl = 256.000000;
							if ((self.ammo_shells < 2.000000))
							{
								am = 1.000000;
							}
							else
							{
								sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
							}
						}
					}
					else
					{
						if ((self.impulse == 4.000000))
						{
							// Long Range Pipe-Bombs
							if ((it & 2048.000000))
							{
								fl = 2048.000000;
								if ((self.ammo_rockets < 3.000000))
								{
									am = 3.000000;
								}
								else
								{
									sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
								}
								self.weaponmode = 1.000000;
								self.option = 1.000000;
							}
							else
							{
								fl = 512.000000;
								if ((self.ammo_nails < 1.000000))
								{
									am = 1.000000;
								}
								else
								{						
									if ((self.playerclass != 8.000000))
									{
										sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
									}
								}									
							}							
						}
						else
						{
							if ((self.impulse == 5.000000))
							{
								if ((it & 1024.000000))
								{
									fl = 1024.000000;
									if ((self.ammo_nails < 2.000000))
									{
										am = 1.000000;
									}
									else
									{
										sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
									}
								}
								else
								{
									if ((it & 2048.000000))
									{
										fl = 2048.000000;
										if ((self.ammo_rockets < 2.000000))
										{
											am = 2.000000;
										}
										else
										{
											sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
										}
										self.weaponmode = 0.000000;
										self.option = 1.000000;
									}
									else
									{
										have_weapon = 0.000000;
									}
								}
							}
							else
							{
								if ((self.impulse == 6.000000))
								{
									if ((it & 4096.000000))
									{
										fl = 4096.000000;
										if ((self.ammo_cells < 1.000000))
										{
											am = 1.000000;
										}
										else
										{
											sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
										}
									}
									else
									{
										if ((it & 2048.000000))
										{
											fl = 2048.000000;
											if ((self.ammo_rockets < 1.000000))
											{
												am = 1.000000;
											}
											else
											{
												sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
											}
											self.weaponmode = 0.000000;
											self.option = 0.000000;
										}
										else
										{
											have_weapon = 0.000000;
										}
									}
								}
								else
								{
									if ((self.impulse == 7.000000))
									{
										if ((it & 16384.000000))
										{
											fl = 16384.000000;
											if ((self.ammo_rockets < 3.000000))
											{
												am = 1.000000;
											}
											else
											{
												sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
											}
										}
										else
										{
											if ((it & 8192.000000))
											{
												fl = 8192.000000;
												if ((self.ammo_rockets < 1.000000))
												{
													am = 1.000000;
												}
												else
												{
													sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
												}
											}
											else
											{
												if ((it & 32768.000000))
												{
													if (self.option4)
													{
														self.option4 = 0.000000;
														sprint (self, 2.000000, "Assault cannon selected\n");
														if ((self.ammo_cells < 4.000000))
														{
															am = 2.000000;
														}
													}
													else
													{
														self.option4 = 1.000000;
														sprint (self, 2.000000, "20mm cannon selected\n");
													}
													fl = 32768.000000;
													if ((self.ammo_shells < 1.000000))
													{
														am = 1.000000;
													}
													else
													{
														sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
													}
												}
												else
												{
													if ((it & 2048))
													{
														fl = 2048;
														self.weaponmode = 1;
														self.option = 0.000000;
														if ((self.ammo_rockets < 1))
														{
															am = 1;
														}
														else
														{
															sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
														}
													}
													else
													{
														have_weapon = 0.000000;
													}
												}
											}
										}
									}
									else
									{
										self.impulse = 8.000000;
										if ((/*8.000000 && */(self.playerclass == 8.000000)))
										{
											fl = 1.000000;
											if (!allow_hook)
											{
												am = 1.000000;
											}
										}
										else
										{
											self.impulse = 176.000000;
											if (self.impulse == 176.000000)
											{
												fl = 4.000000;
												if ((it & 4.000000))
												{
													usable = 1.000000;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	self.impulse = 0.000000;
	if ((!have_weapon || !(it & fl)))
	{
		sprint (self, 2.000000, "no weapon.\n");
		return;
	}
	if ((am == 1.000000))
	{
		sprint (self, 2.000000, "not enough ammo.\n");
		return;
	}
	if ((am == 2.000000))
	{
		sprint (self, 2.000000, "not enough cells to power assault cannon.\n");
		return;
	}
	self.current_weapon = fl;
	W_SetCurrentAmmo ();
	W_PrintWeaponMessage ();
	self.StatusRefreshTime = (time + 0.100000);
};

void () CycleWeaponCommand =
{
	local float it;
	local float am;
	local float cont;
	local float loopcount;

	if (((self.weaponmodel == string_null) || (self.current_weapon == 0.000000)))
	{
		return;
	}
	if ((self.tfstate & 2))
	{
		return;
	}
	if ((self.tools == (self.tools | 32)))
	{
		return;
	}
	it = self.weapons_carried;
	self.impulse = 0.000000;
	loopcount = 0.000000;
	while (1)
	{
		am = 0.000000;
		cont = 0.000000;
		if ((self.current_weapon == 16))
		{
			self.current_weapon = 8;
		}
		else
		{
			if ((self.current_weapon == 8))
			{
				self.current_weapon = 128;
				if ((self.ammo_shells < 1))
				{
					am = 1;
				}
			}
			else
			{
				if ((self.current_weapon == 128))
				{
					self.current_weapon = 524288;
					if ((self.ammo_nails < 1))
					{
						am = 1;
					}
				}
				else
				{
					if ((self.current_weapon == 524288))
					{
						self.current_weapon = 262144;
						if ((self.ammo_shells < 1))
						{
							am = 1;
						}
					}
					else
					{
						if ((self.current_weapon == 262144))
						{
							self.current_weapon = 32;
							if ((self.ammo_shells < 1))
							{
								am = 1;
							}
						}
						else
						{
							if ((self.current_weapon == 32))
							{
								self.current_weapon = 64;
								if ((self.ammo_shells < 1))
								{
									am = 1;
								}
							}
							else
							{
								if ((self.current_weapon == 64))
								{
									self.current_weapon = 256;
									if ((self.ammo_shells < 2))
									{
										am = 1;
									}
								}
								else
								{
									if ((self.current_weapon == 256))
									{
										self.current_weapon = 512;
										if ((self.ammo_nails < 1))
										{
											am = 1;
										}
									}
									else
									{
										if ((self.current_weapon == 512))
										{
											self.current_weapon = 1024;
											if ((self.ammo_nails < 2))
											{
												am = 1;
											}
										}
										else
										{
											if ((self.current_weapon == 1024))
											{
												self.current_weapon = 2048;
												self.weaponmode = 0.000000;
												if ((self.ammo_rockets < 1))
												{
													am = 1;
												}
											}
											else
											{
												if (((self.current_weapon == 2048) && (self.weaponmode == 0.000000)))
												{
													self.current_weapon = 2048;
													self.weaponmode = 1;
													if ((self.ammo_rockets < 1))
													{
														am = 1;
													}
												}
												else
												{
													if (((self.current_weapon == 2048) && (self.weaponmode == 0.000000)))
													{
														self.current_weapon = 2048;
														self.weaponmode = 0.000000;
														self.option = 1;
														if ((self.ammo_rockets < 1))
														{
															am = 1;
														}
													}
													else
													{
														if (((self.current_weapon == 2048) && (self.weaponmode == 1)))
														{
															self.current_weapon = 8192;
															if ((self.ammo_rockets < 1))
															{
																am = 1;
															}
														}
														else
														{
															if ((self.current_weapon == 8192))
															{
																self.current_weapon = 65536;
																if ((self.ammo_cells < 1))
																{
																	am = 1;
																}
															}
															else
															{
																if ((self.current_weapon == 65536))
																{
																	self.current_weapon = 4096;
																	if ((self.ammo_cells < 1))
																	{
																		am = 1;
																	}
																}
																else
																{
																	if ((self.current_weapon == 4096))
																	{
																		self.current_weapon = 16384;
																		if ((self.ammo_rockets < 3))
																		{
																			am = 1;
																		}
																	}
																	else
																	{
																		if ((self.current_weapon == 16384))
																		{
																			self.current_weapon = 32768;
																			if ((self.ammo_cells < 6))
																			{
																				am = 1;
																			}
																			if ((self.ammo_shells < 1))
																			{
																				am = 1;
																			}
																		}
																		else
																		{
																			if ((self.current_weapon == 32768))
																			{
																				self.current_weapon = 1;
																				if (!allow_hook)
																				{
																					am = 1;
																				}
																			}
																			else
																			{
																				if ((self.current_weapon == 1))
																				{
																					self.current_weapon = 2;
																				}
																				else
																				{
																					if ((self.current_weapon == 2))
																					{
																						self.current_weapon = 4;
																					}
																					else
																					{
																						if ((self.current_weapon == 4))
																						{
																							self.current_weapon = 16;
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((loopcount > 30))
		{
			return;
		}
		loopcount = (loopcount + 1);
		if (((self.weapons_carried & self.current_weapon) && (am == 0.000000)))
		{
			if ((self.current_weapon != 2048))
			{
				self.weaponmode = 0.000000;
			}
			W_SetCurrentAmmo ();
			W_PrintWeaponMessage ();
			self.StatusRefreshTime = (time + 0.1);
			return;
		}
	}
};
void () DeadImpulses;
//void () FireUtil;

void () ImpulseCommands =
{
	local string _l_3204;

	_l_3204 = infokey (self, "tf_help");
	if (prematch)
	{
		if (((((((self.impulse == 120.000000) || (self.impulse == 136.000000)) || (self.impulse == 119.000000)) || (self.impulse == 186.000000)) || (self.impulse == 187.000000)) || ((self.impulse >= 236.000000) && (self.impulse <= 239.000000))))
		{
			DeadImpulses ();
		}
		if ((!(((self.impulse >= 1.000000) && (self.impulse < 9.000000)) || (self.impulse == 176.000000)) && !((self.impulse >= 100.000000) && (self.impulse <= 110.000000))))
		{
			self.impulse = 0.000000;
			return;
		}
	}
	if ((self.tools == (self.tools | 32.000000)))
	{
		return;
	}
	if ((self.impulse == 211.000000))
	{
		TeamFortress_ToggleGenderMessage();
	}
	if (((self.last_impulse == 168.000000) && self.impulse))
	{
		TeamFortress_SetDetpack (self.impulse);
	}
	else
	{
		if (((self.last_impulse == 159.000000) && self.impulse))
		{
			TeamFortress_Scan (self.impulse);
		}
	}
	if ((((self.impulse == 8.000000) && (self.current_menu != 6.000000)) && (self.playerclass != 8.000000)))
	{
		self.current_menu = 6.000000;
		self.menu_count = 25.000000;
		self.menu_displaytime = 0.000000;
	}
	if ((self.impulse == 171.000000))
	{
		UseSpecialSkill ();
	}
	if ((self.impulse == 240.000000))
	{
		bprint2 (1.000000, self.netname, " tried to cheat.\n");
		sprint (self, 2.000000, "You have been kicked for attempting to cheat. Don't do it.\n");
		stuffcmd (self, "disconnect\n");
		stuffcmd (self, "quit\n");
	}
	if (spycam)
	{
		if (((self.impulse == 55.000000) && (self.bugger > 0.000000)))
		{
			Cam ();
		}
		if ((((self.impulse == 55.000000) && (self.is_feigning == 1.000000)) && (self.bugger == 0.000000)))
		{
			Cam ();
		}
	}
	if ((((!self.is_building && !self.is_detpacking) && !self.is_feigning) && (self.bugger == 0.000000)))
	{
		if ((((self.impulse >= 1.000000) && (self.impulse < 9.000000)) || (self.impulse == 176.000000)))
		{
			if ((self.weaponmodel == "progs/proxgren.mdl"))
			{
				if ((self.oldweaponmodel != ""))
				{
					self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
				}
				self.weaponmodel = self.oldweaponmodel;
				self.currentammo = self.oldcurrentammo;
				self.StatusRefreshTime = (time + 0.100000);
			}
			if ((self.weaponmodel == "progs/spycamb.mdl"))
			{
				if ((self.oldweaponmodel != ""))
				{
					self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
				}
				self.weaponmodel = self.oldweaponmodel;
				self.currentammo = self.oldcurrentammo;
				self.StatusRefreshTime = (time + 0.100000);
			}
			W_ChangeWeapon ();
		}
		else
		{
			if ((self.impulse == 40.000000))
			{
				W_ChangeWeapon ();
			}
			else
			{
				if ((allow_hook && ((self.impulse == 22.000000) || (self.impulse == 39.000000))))
				{
					W_ChangeWeapon ();
				}
				else
				{
					if (((self.impulse == 10.000000) || (self.impulse == 12.000000)))
					{
						CycleWeaponCommand ();
					}
					else
					{
						if ((self.impulse == 150.000000))
						{
							TeamFortress_PrimeGrenade ();
						}
						else
						{
							if ((self.impulse == 151.000000))
							{
								TeamFortress_PrimeGrenade ();
							}
							else
							{
								if ((self.impulse == 173.000000))
								{
									TeamFortress_ReloadCurrentWeapon ();
								}
								else
								{
									if ((self.impulse == 162.000000))
									{
										TeamFortress_Scan (10.000000);
									}
									else
									{
										if ((self.impulse == 163.000000))
										{
											TeamFortress_Scan (30.000000);
										}
										else
										{
											if ((self.impulse == 164.000000))
											{
												TeamFortress_Scan (100.000000);
											}
											else
											{
												if ((self.impulse == 157.000000))
												{
													if ((self.last_saveme_sound <= time))
													{
														self.last_saveme_sound = (time + 5.000000);
														muzzleflash ();
														sound (self, 0.000000, "speech/threat.wav", 0.700000, 0.000000);
														self.impulse = 0.000000;
													}
												}
												else
												{
													if ((self.impulse == 156.000000))
													{
														if ((self.last_saveme_sound <= time))
														{
															self.last_saveme_sound = (time + 5.000000);
															muzzleflash ();
															sound (self, 0.000000, "speech/hey.wav", 0.700000, 0.000000);
															self.impulse = 0.000000;
														}
													}
													else
													{
														if ((self.impulse == 58.000000))
														{
															if ((self.last_saveme_sound <= time))
															{
																self.last_saveme_sound = (time + 10.000000);
																muzzleflash ();
																sound (self, 0.000000, "speech/cmyhole.wav", 0.700000, 0.000000);
																self.impulse = 0.000000;
															}
														}
														else
														{
															if ((self.impulse == 158.000000))
															{
																if ((self.is_squating == 1.000000))
																{
																	self.is_squating = 0.000000;
																	self.frame = 0.000000;
																	unlay ();
																	sprint (self, 2.000000, "Standing mode, (normal)\n");
																}
																else
																{
																	self.is_squating = 1.000000;
																	lay ();
																	sprint (self, 2.000000, "Laying mode, (stop walking to lay)\n");
																}
															}
															else
															{
																if ((self.impulse == 155.000000))
																{
																	if ((self.playerclass == 1.000000))
																	{
																		SuperLeap ();
																	}
																	//self.movetype = 5.000000; //yeah this caused flying on FTE/ZQuake servers
																				    //since apparently movetype 5 is fly for them :\
																	self.movetype = 3;
																}
																else
																{
																	if ((self.impulse == 154.000000))
																	{
																		sprint (self, 2.000000, "--- Airscout Info ---\n");
																		sprint (self, 2.000000, "Def: A Scout that can jump very high\n");
																		sprint (self, 2.000000, "Cmd: 'jetjump' or Impulse 155.\n");
																		sprint (self, 2.000000, "    Uses 25 battery cells per jump.\n");
																		sprint (self, 2.000000, "    Aim higher than you want to go.\n");
																		sprint (self, 2.000000, "Use:  Must be a scout,\n");
																		self.impulse = 0.000000;
																	}
																	else
																	{
																		if (((self.impulse == 190.000000) && (self.flags & 512.000000)))
																		{
																			if (!drop1)
																			{
																				sprint (self, 2.000000, "Type 1 weapons disabled by Admin!\n");
																				self.impulse = 0.000000;
																				return;
																			}
																			if ((self.playerclass == 2.000000))
																			{
																				A_Mine ();
																				self.impulse = 0.000000;
																			}
																			else
																			{
																				if ((self.playerclass == 5.000000))
																				{
																					B_Mine ();
																					self.impulse = 0.000000;
																				}
																				else
																				{
																					if ((self.playerclass == 9.000000))
																					{
																						M_Mine ();
																						self.impulse = 0.000000;
																					}
																					else
																					{
																						if ((self.playerclass == 1.000000))
																						{
																							C_Mine ();
																							self.impulse = 0.000000;
																						}
																						else
																						{
																							if ((self.playerclass == 3.000000))
																							{
																								S_Mine ();
																								self.impulse = 0.000000;
																							}
																							else
																							{
																								if ((self.playerclass == 6.000000))
																								{
																									S_Mine ();
																									self.impulse = 0.000000;
																								}
																								else
																								{
																									if ((self.playerclass == 8.000000))
																									{
																										SpyPack ();
																										self.impulse = 0.000000;
																									}
																									else
																									{
																										if ((self.playerclass == 4.000000))
																										{
																											BalloonMIRV ();
																											self.impulse = 0.000000;
																										}
																										else
																										{
																											if ((self.playerclass == 7.000000))
																											{
																												LavaPool ();
																												self.impulse = 0.000000;
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																		else
																		{
																			if ((self.impulse == 201.000000))
																			{
																				W_LaunchStinger ();
																				self.impulse = 0.000000;
																			}
																			else
																			{
																				if ((self.impulse == 55.000000))
																				{
																					if (!drop3)
																					{
																						sprint (self, 2.000000, "Type 3 weapons disabled by Admin!\n");
																						self.impulse = 0.000000;
																						return;
																					}
																					if ((self.playerclass == 9.000000))
																					{
																						Drone ();
																					}
																					if ((self.playerclass == 5.000000))
																					{
																						HealSelf ();
																					}
																					if ((self.playerclass == 8.000000))
																					{
																						if (spycam)
																						{
																							Cam ();
																						}
																					}
																					if ((self.playerclass == 3.000000))
																					{
																						Prox ();
																					}
																					if ((self.playerclass == 1.000000))
																					{
																						DetpackDisarm ();
																					}
																					if (((self.playerclass == 2.000000) && (self.has_syringe == 1.000000)))
																					{
																						self.option = 9.000000;
																					}
																					self.impulse = 0.000000;
																				}
																				else
																				{
																					if ((self.impulse == 200.000000))
																					{
																						MakeHolo ();
																						self.impulse = 0.000000;
																					}
																					else
																					{
																						if ((self.impulse == 249.000000))
																						{
																							W_LaunchStinger ();
																						}
																						else
																						{
																							if ((self.impulse == 250.000000))
																							{
																								if ((self.last_saveme_sound <= time))
																								{

																									local string version_finder;
																									version_finder = infokey(world, "MegaTF");

																									self.last_saveme_sound = (time + 5.000000);
																									muzzleflash ();
																									sound (self, 1.000000, "speech/pantsdwn.wav", 1.000000, 1.000000);
																									sprint (self, 1.000000, "MegaTF ",version_finder,"\n");
																									self.impulse = 0.000000;
																								}
																							}
																							else
																							{
																								if ((self.impulse == 165.000000))
																								{
																									TeamFortress_SetDetpack (5.000000);
																								}
																								else
																								{
																									if ((self.impulse == 166.000000))
																									{
																										TeamFortress_SetDetpack (20.000000);
																									}
																									else
																									{
																										if ((self.impulse == 167.000000))
																										{
																											TeamFortress_SetDetpack (50.000000);
																										}
																										else
																										{
																											if ((self.impulse == 172.000000))
																											{
																												self.current_menu = 4.000000;
																												self.menu_count = 20.000000;
																											}
																											else
																											{
																												if ((self.impulse == 184.000000))
																												{
																													TeamFortress_Discard ();
																												}
																												else
																												{
																													if ((self.impulse == 57.000000))
																													{
																														if ((self.playerclass == 0.000000))
																														{
																															return;
																														}
																														self.current_menu = 20.000000;
																														self.menu_count = 20.000000;
																													}
																													else
																													{
																														if ((self.impulse == 53.000000))
																														{
																															if ((self.playerclass == 0.000000))
																															{
																																return;
																															}
																															self.current_menu = 21.000000;
																															self.menu_count = 20.000000;
																														}
																														else
																														{
																															if ((self.impulse == 56.000000))
																															{
																																if ((self.playerclass == 0.000000))
																																{
																																	return;
																																}
																																self.current_menu = 22.000000;
																																self.menu_count = 20.000000;
																															}
																															else
																															{
																																if ((self.impulse == 251))
																																{
																																	self.current_menu = 23;
																																	self.menu_count = 20;
																																}
																																else
																																{
																																if ((self.impulse == 245))
																																{
																																	voteyes ();																																																																			}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if ((self.impulse == 135))
	{
		TeamFortress_Inventory ();
	}
	else
	{
		if ((self.impulse == 181))
		{
			TeamFortress_SaveMe ();
		}
		else
		{
			if (((self.impulse == 50) || (self.impulse == 50)))
			{
				if ((self.vision != 1))
				{
					self.vision = 1;
					stuffcmd (self, "v_cshift 0 100 0 100\n");
				}
				else
				{
					self.vision = 0.000000;
					stuffcmd (self, "v_cshift 0 0 0 0\n");
				}
			}
			else
			{
				if ((self.impulse == 60))
				{
					TeamFortress_Spotlight();
					self.impulse = 0.000000;
				}
				else
				{
					if (((self.impulse == 61) && (self.playerclass == 2)))
					{
						if ((self.option4 == 1.000000))
						{
							sprint (self, 2.000000, "Laser Sight On\n");
							self.option4 = 0.000000;
						}
						else
						{
							sprint (self, 2.000000, "Laser Sight Off\n");
							self.option4 = 1.000000;
						}
					}
					else
					{
//						if ((self.impulse == 51))
//						{
//							self.impulse = 0.000000;
//							self.has_syringe = 1;
//							if (((self.playerclass == 2) && 1))
//							{
//								self.option = 9;
//							}
//						}
//						else
//						{
							if ((self.impulse == 152))
							{
								TeamFortress_ThrowGrenade ();
							}
							else
							{
								if (self.impulse == 185)
								{
									TeamFortress_ID ();
								}
								else
								{
									if ((self.impulse == 170))
									{
										TeamFortress_DetonatePipebombs ();
									}
									else
									{
										if ((self.impulse == 169))
										{
											TeamFortress_DetpackStop ();
										}
										else
										{
											if (((self.impulse == 177) && (self.playerclass == 8)))
											{
												TeamFortress_SpyGoUndercover ();
											}
											else
											{
												if ((((self.impulse == 178) && (self.playerclass == 8)) && !self.hook_out))
												{
													TeamFortress_SpyFeignDeath (0);
												}
												else
												{
												if ((((self.impulse == 180.000000) && (self.playerclass == 8.000000)) && !self.hook_out))
												{
													if ((self.weaponmodel != "progs/spycamb.mdl"))
													{
														TeamFortress_SpyFeignDeath (1.000000);
													}
												}
												else
												{
													if (((self.impulse == 179) && (self.playerclass == 9)))
													{
														TeamFortress_EngineerBuild ();
													}
													else
													{
														if ((self.impulse == 23))
														{
															if ((CTF_Map == 1))
															{
																TeamFortress_CTF_FlagInfo ();
															}
															else
															{
																TeamFortress_DisplayDetectionItems ();
															}
														}
														else
														{
															if ((self.impulse == 118))
															{
																display_location ();
															}
															else
															{
																//if ((self.impulse == 191))
																//{
//																//	FireUtil ();
																//}
																//else
																//{
																	if (self.impulse != 245) { DeadImpulses (); }
																//}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
//					}
				}
			}
		}
	} }
/* gold.  moved to dead impulses
	if ((self.impulse == 202))
	{
		self.current_menu = 3;
		self.menu_displaytime = 25;
		self.menu_count = 25;
		self.oldcurrentammo = 1;
	}
*/
	if (self.impulse == 189)
	{
		HealSelf();
	}
	if (self.impulse == 203)
	{
#ifdef tf29ents
		DropGoalItems ();
#else
		DropFlag();
#endif
	}
#ifdef clan_progs
	if (self.impulse == 206)
	{
		DropGoalItems();
	}
#endif
	if(self.impulse == 188)
	{
		Det_Disp();
	}
	if(self.impulse == 205)
	{
		Det_Sent();
	}
	if ((self.impulse == 234.000000))
	{
		TeamFortress_ItemStatus (1.000000);
	}
	if ((self.impulse == 235.000000))
	{
		TeamFortress_ItemStatus (0.000000);
	}
	if ((self.impulse == 241.000000))
	{
		TeamFortress_ItemStatus (11.000000);
	}
	if ((self.impulse == 242.000000))
	{
		TeamFortress_ItemStatus (10.000000);
	}
/*  gold.  moved to deadimpulses
	if(self.impulse == 120)
	{
		TeamFortress_Timeleft();
	}
*/
	if(self.impulse == 204)
	{
#ifdef tf29ents
		DropGoalItems ();
#else
		DropFlag();
#endif
	}
	if ((self.impulse == 168))
	{
		self.last_impulse = self.impulse;
	}
	if ((self.impulse == 159))
	{
		self.last_impulse = self.impulse;
	}
	self.impulse = 0.000000;
};

#ifdef clan_progs
void () Rank_ShowStats;
#endif
void () DeadImpulses =
{
#ifdef clan_progs
	if ((self.impulse == 69))
	{
		Rank_ShowStats();
	}
#else
	if ((self.impulse == 69))
	{
		testfunct ();
	}
#endif
	if ((self.impulse == 202))
	{
		self.current_menu = 3;
		self.menu_displaytime = 25;
		self.menu_count = 25;
		self.oldcurrentammo = 1;
	}
// so you can vote when dead
	if ((self.impulse == 245))
	{
		voteyes();
	}
	if ((self.impulse == 120))
	{
		TeamFortress_Timeleft();
	}
	if ((self.impulse == 136))
	{
		TeamFortress_ShowTF ();
	}
	else
	{
		if ((self.impulse == 174))
		{
			TeamFortress_AutoZoomToggle ();
		}
		else
		{
			if ((self.impulse == 137))
			{
				TeamFortress_DisplayLegalClasses ();
			}
			else
			{
				if (((self.impulse >= 100) && (self.impulse <= (100 + 10))))
				{
					TeamFortress_ChangeClass ();
				}
				else
				{
					if ((self.impulse == 131))
					{
						TeamFortress_HelpMap ();
					}
					else
					{
						if ((self.impulse == 119))
						{
							TeamFortress_StatusQuery ();
						}
						else
						{
							if ((self.impulse == 140))
							{
								TeamFortress_TeamSet (1);
							}
							else
							{
								if ((self.impulse == 141))
								{
									TeamFortress_TeamSet (2);
								}
								else
								{
									if ((self.impulse == 142))
									{
										TeamFortress_TeamSet (3);
									}
									else
									{
										if ((self.impulse == 143))
										{
											TeamFortress_TeamSet (4);
										}
										else
										{
											if ((self.impulse == 145))
											{
												TeamFortress_TeamShowScores (0.000000);
											}
											else
											{
												if ((self.impulse == 144))
												{
													TeamFortress_TeamShowMemberClasses (self);
												}
												else
												{
													if ((self.impulse == 182))
													{
														self.StatusRefreshTime = (time + 0.2);
														self.StatusBarSize = (self.StatusBarSize + 1);
														if ((self.StatusBarSize > 2))
														{
															self.StatusBarSize = 1;
														}
													}
													else
													{
														if ((self.impulse == 183))
														{
															self.StatusRefreshTime = (time + 60);
															self.StatusBarSize = 0.000000;
														}
														else
														{
															if (((self.impulse >= 71) && (self.impulse <= 81)))
															{
																StatusRes ((self.impulse - 71));
															}
															else
															{
																if ((self.impulse == 13))
																{
																	sprint (self, 2, "Aliases checked.\n");
																	self.got_aliases = 1;
																	self.impulse = 0.000000;
																}
																else
																{
																	if ((self.impulse == 186.000000))
																	{
																		if ((self.autoid != 1.000000))
																		{
																			sprint (self, 2.000000, "Auto Identify On\n");
																		}
																		self.autoid = 1.000000;
																		self.impulse = 0.000000;
																	}
																	else
																	{
																		if ((self.impulse == 187.000000))
																		{
																			if ((self.autoid != 0.000000))
																			{
																				sprint (self, 2.000000, "Auto Identify Off\n");
																			}
																			self.autoid = 0.000000;
																			self.impulse = 0.000000;
																		}
																		else
																		{
																			if ((self.impulse == 236.000000))
																			{
																				if ((self.discard_max != 1.000000))
																				{
																					sprint (self, 2.000000, "Discarding set to Max\n");
																				}
																				self.discard_max = 1.000000;
																				self.impulse = 0.000000;
																			}
																			else
																			{
																				if ((self.impulse == 237.000000))
																				{
																					if ((self.discard_max != 0.000000))
																					{
																						sprint (self, 2.000000, "Discarding set to Normal\n");
																					}
																					self.discard_max = 0.000000;
																					self.impulse = 0.000000;
																				}
																				else
																				{
																					if ((self.impulse == 238.000000))
																					{
																						if ((self.autodiscard != 1.000000))
																						{
																							sprint (self, 2.000000, "Auto Discard On\n");
																						}
																						self.autodiscard = 1.000000;
																						self.impulse = 0.000000;
																					}
																					else
																					{
																						if ((self.impulse == 239.000000))
																						{
																							if ((self.autodiscard != 0.000000))
																							{
																								sprint (self, 2.000000, "Auto Discard Off\n");
																							}
																							self.autodiscard = 0.000000;
																							self.impulse = 0.000000;
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};

void () W_WeaponFrame =
{
	local vector tv;
	local string he;

	he = infokey (self, "tf_help");
	if (!(self.tfstate & 2048.000000))
	{
		if (((self.height > 29.000000) && (self.height < 90.000000)))
		{
			self.height = (self.height + 8.000000);
			if ((self.height > 90.000000))
			{
				self.height = 90.000000;
			}
			TF_zoom (self.height);
		}
	}
	if ((self.current_menu > 0.000000))
	{
		Player_Menu ();
		if (((self.impulse > 0.000000) && (self.impulse < 11.000000)))
		{
			Menu_Input (self.impulse);
			if ((self.impulse != 0.000000))
			{
				if ((((self.team_no == 0.000000) && teamplay) && (self.lives != 0.000000)))
				{
					Menu_Team_Input (self.impulse);
				}
				else
				{
					if (((self.playerclass == 0.000000) && (self.lives != 0.000000)))
					{
						Menu_Class_Input (self.impulse);
					}
				}
			}
		}
	}
#ifdef clan_progs
//grenade throw lag fix (sticky grenades)
	if (self.tfstate & 32768) // if player is tranq'd, do not do this anti-sticky function
	{
		if ((time < self.attack_finished))
		{
			return;
		}
		if ((self.impulse != 0.000000))
		{
			ImpulseCommands ();
		}
	}
	else
	{
		if ((time < self.attack_finished))
		{
			if (self.impulse == 152 || self.impulse == 151 || self.impulse == 150 || self.impulse == 191)
			{
				ImpulseCommands ();
			}
			else
			{
				return;
			}
		}
	}
#else
	if ((time < self.attack_finished))
	{
		return;
	}
#endif
	if ((self.impulse != 0.000000))
	{
		ImpulseCommands ();
	}
	if ((((self.is_building != 0.000000) || (self.is_detpacking != 0.000000)) || (self.is_feigning != 0.000000)))
	{
		return;
	}
	if (((!self.button0 && self.fire_held_down) && (self.current_weapon == 32768.000000)))
	{
		if ((self.tfstate & 131072.000000))
		{
			self.tfstate = (self.tfstate - 131072.000000);
		}
		self.fire_held_down = 0.000000;
		TeamFortress_SetSpeed (self);
		player_run ();
	}
	if ((self.button0 && !self.fire_held_down))
	{
		if (((self.current_menu == 6.000000) || (self.current_menu == 7.000000)))
		{
			self.current_menu = 8.000000;
			self.menu_count = 25.000000;
			Attack_Finished (0.200000);
		}
		else
		{
			if ((self.current_weapon == 32.000000))
			{
				if ((self.tfstate & 2048.000000))
				{
#ifndef clan_progs
					if ((self.heat < 400.000000))
					{
						self.heat = (self.heat + 3.000000);
					}
#endif
					if ((self.height > 30.000000))
					{
						self.height = (self.height - 5.000000);
						TF_zoom (self.height);
					}
				}
				else
				{
					tv = self.velocity;
					tv_z = 0.000000;
					if ((vlen (tv) <= 50.000000))
					{
						SniperSight_Create ();
#ifdef clan_progs
						self.heat = time; // damage done // PZ - 50 -> time (Randomer's charge-up fix)
#else
						self.heat = 50.000000;
#endif
						self.height = 90.000000;
						self.tfstate = (self.tfstate | 2048.000000);
						TeamFortress_SetSpeed (self);
					}
				}
			}
			else
			{
				if ((self.current_weapon == 32768.000000))
				{
					if ((self.flags & 512.000000))
					{
						SuperDamageSound ();
						W_Attack ();
					}
					else
					{
						if ((he != "off"))
						{
							if (self.hw_message_resttime < time)
							{
								sprint (self, 1.000000, "You cannot fire the assault cannon without\nyour feet on the ground...\n");
								self.hw_message_resttime = time + 0.5;
							}
						}
					}
				}
				else
				{
					SuperDamageSound ();
					W_Attack ();
				}
			}
		}
	}
	else
	{
		if ((self.playerclass == 0.000000))
		{
			self.weaponmode = 0.000000;
		}
		else
		{
			if ((self.tfstate & 2048.000000))
			{
				W_Attack ();
				self.tfstate = (self.tfstate - 2048.000000);
				TeamFortress_SetSpeed (self);
				self.heat = 0.000000;
			}
		}
	}
};

void () SuperDamageSound =
{
	if ((self.super_damage_finished > time))
	{
		if ((self.super_sound < time))
		{
			self.super_sound = (time + 1);
			sound (self, 4, "items/damage3.wav", 1, 1);
		}
	}
	return;
};
//void (vector where) make_bub;
void (float num_bubbles) DeathBubbles;

// pablo. This should be out. vvv
/*float (entity hwguy) hwguy_deflect =
{
	local entity FlashTimer;
	local vector top;
	local vector bottom;
	local vector deflection;
	local vector def_angles;
	local vector dir;

	if ((trace_ent.team_no == self.team_no))
	{
		return 0;
	}
//	if ((hwguy.shieldOn == TF_FLARE_LIT))
//	{
//		return (TF_FLARE_LIT);
//	}
//	if ((hwguy.ammo_cells < 100))
//	{
//		sprint (hwguy, TF_FLARE_OFF, "You are out of cells for force field!!!\n");
//		return (TF_FLARE_LIT);
//	}
	FlashTimer = spawn ();
	FlashTimer.classname = "timer";
	FlashTimer.owner = hwguy;
	FlashTimer.team_no = self.team_no;
	FlashTimer.nextthink = (time + 0.1);
	FlashTimer.think = endFlash;
	stuffcmd (hwguy, "v_cshift 0 0 128 64\n");
	hwguy.ammo_cells = (hwguy.ammo_cells - 10);
	if ((self.classname == "player"))
	{
		makevectors (self.v_angle);
		dir = normalize (v_forward);
		traceline (self.origin, (self.origin + (dir * 4096)), TF_FLARE_LIT, self);
		deflection = (trace_endpos - hwguy.origin);
		deflection = normalize (deflection);
		launch_spike (trace_endpos, deflection);
		sound (hwguy, TF_FLARE_OFF, "artifact/shield.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		spawn_tfog (trace_endpos);
	}
	else
	{
		deflection = (self.origin - hwguy.origin);
		deflection = normalize (deflection);
		deflection = (deflection * vlen (self.velocity));
		def_angles = vectoangles (deflection);
		self.velocity = deflection;
		self.angles = def_angles;
		sound (self, TF_FLARE_OFF, "artifact/shield.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		top = (self.origin + '0 0 5');
		bottom = (self.origin - '0 0 5');
		spawn_tfog (self.origin);
		traceline (top, bottom, TF_FLARE_OFF, hwguy);
		WriteByte (4, 23);
		WriteByte (4, 6);
		WriteEntity (4, self);
		WriteCoord (4, top_x);
		WriteCoord (4, top_y);
		WriteCoord (4, top_z);
		WriteCoord (4, trace_endpos_x);
		WriteCoord (4, trace_endpos_y);
		WriteCoord (4, trace_endpos_z);
		multicast (top, TF_FLARE_OFF);
	}
	return (TF_FLARE_OFF);
};

void () endFlash =
{
	stuffcmd (self.owner, "v_cshift 0 0 0 0\n");
	dremove (self);
};
*/
//#warning "Could not determine return type"
//float () AxeTouch;
void (string gibname,float dm) ThrowGib;

void () SUB_Gib =
{
	local vector x;
	local vector y;
	local vector v;
	local float r_num;

	if ((other.team_no == self.team_no))
	{
		return;
	}
	r_num = random ();
	if ((r_num < 0.6))
	{
		x = '1 0 0';
		y = '0 1 0';
		v = ((x * (50 - (random () * 100))) + (y * (50 - (random () * 100))));
		r_num = random ();
		SpawnMeatSpray (self.origin, v);
	}
	else
	{
		if ((r_num >= 0.6))
		{
			ThrowGib ("progs/gib1.mdl", self.health);
		}
		else
		{
			ThrowGib ("progs/gib3.mdl", self.health);
		}
	}
};


/*
#warning "Could not determine return type"
float () AxeTouch =
{
	local float clink;
	local entity stemp;
	local float ndmg;
	local float deflect;
	local vector v;

	ndmg = 50;
// pablo. bounces? doesnt seem like mega :/
//	if (((other == self.owner) && (self.num_bounces == 0.000000)))
//	{
//		return;
//	}
//
//	if (((other.playerclass == 7) && (other.team_no != self.team_no)))
//	{
//		deflect = hwguy_deflect (other);
//		if (deflect)
//		{
//			return;
//		}
//	}
	self.avelocity = '300 300 300';
	self.movetype = 10;
	setsize (self, '-1 -2 -3', '1 2 3');
	if ((other.takedamage && (self.velocity != '0 0 0')))
	{
		if ((self.num_bounces == 0.000000))
		{
			spawn_touchblood (40);
			SUB_Gib ();
			deathmsg = 47;
			other.punchangle_x = -20.000000;
			other.axhitme = 1;
			TF_T_Damage (other, self, self.owner, ndmg, 50, 50);
		}
	}
	else
	{
		clink = (random () * 2);
		if ((clink <= 1))
		{
			sound (self, 1, "player/axhit2.wav", 1, 0.000000);
		}
		else
		{
			sound (self, 1, "weapons/tink1.wav", 1, 0.000000);
		}
	}
	self.num_bounces = (self.num_bounces + 1);
	if ((self.num_bounces > 22))
	{
		SUB_Remove ();
	}
	if ((other.num_axes >= 10))
	{
		sprint (other, 2, "Max axe limit reached!\n");
		return (SUB_Remove ());
	}
//	if ((((other.classname == "player") && (self.velocity == '0 0 0')) && (self.num_axes <= 10)))
//	{
//		sound (other, 3, "weapons/pkup.wav", 1, 0.000000);
//		sprint (other, 2, "You Got A Throwing Axe!\n");
//		other.num_axes = (other.num_axes + 1);
//		self.currentammo = self.num_axes;
//		W_SetCurrentAmmo ();
//		stemp = self;
//		self = other;
//		W_SetCurrentAmmo ();
//		self = stemp;
//		remove (self);
//	}
};
/*
void () W_ThrowAxe =
{
	local entity missile;

	sound (self, 1, "weapons/woosh.wav", 1, 0.000000);
	self.punchangle_x = -6.000000;
	missile = spawn ();
	missile.owner = self;
	missile.team_no = self.team_no;
	missile.movetype = 9;
	missile.solid = 1;
	makevectors (self.v_angle);
	missile.velocity = aim (self, 10000);
	missile.angles = vectoangles (missile.velocity);
	missile.velocity = (missile.velocity * 600);
	missile.touch = AxeTouch;
	missile.nextthink = (time + 10);
	missile.think = SUB_Remove;
	setmodel (missile, "progs/throwaxe.mdl");
	setsize (missile, '0 0 0', '0 0 0');
	setorigin (missile, ((self.origin + (v_forward * 2)) + '0 0 16'));
	missile.avelocity = '-500 0 0';
	missile.num_bounces = 0.000000;
	self.num_axes = (self.num_axes - 1);
	self.currentammo = self.num_axes;
	W_SetCurrentAmmo ();
};
void () LTB_Arm;

void () W_FireLTB =
{
	local vector source;
	local entity lasertrip;
	local entity te;
	local float numWires;

	numWires = 1;
	te = find (world, classname, "trip_bomb");
	while (te)
	{
		if ((te.real_owner == self))
		{
			numWires = (numWires + 1);
		}
		te = find (te, classname, "trip_bomb");
	}
	if ((self.no_grenades_2 < 2))
	{
		sprint (self, 2, "You need 2 Type 2 grenades\n");
		return;
	}
	if ((numWires > 2))
	{
		sprint (self, 2, "2 Laser Trip Wires at a time\n");
		return;
	}
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	if ((trace_plane_normal_z != 0.000000))
	{
		return;
	}
	if ((trace_ent != world))
	{
		return;
	}
	self.no_grenades_2 = (self.no_grenades_2 - 2);
	lasertrip = spawn ();
	lasertrip.owner = self;
	lasertrip.real_owner = self;
	lasertrip.movetype = 0.000000;
	lasertrip.solid = 2;
	lasertrip.classname = "trip_bomb";
	lasertrip.team_no = self.team_no;
	lasertrip.angles = vectoangles (trace_plane_normal);
	lasertrip.takedamage = 1;
	lasertrip.health = 3;
	lasertrip.th_die = LTB_Detonate;
	lasertrip.think = LTB_Arm;
	lasertrip.nextthink = (time + 1);
	lasertrip.attack_finished = (time + 0.01);
	setmodel (lasertrip, "progs/charge.mdl");
	setsize (lasertrip, '0 0 0', '0 0 0');
	setorigin (lasertrip, trace_endpos);
	sound (self, 1, "weapons/deploy.wav", 1, 1);
	sprint (self, 2, "Laser Trip Wire set\n");
};

void () LTB_Arm =
{
	local vector org;
	local vector targ;
	local entity te;

	makevectors (self.angles);
	org = (self.origin + self.view_ofs);
	targ = (org + (v_forward * 150));
	traceline (org, targ, 0.000000, self);
	if ((trace_fraction == 1))
	{
		sprint (self.real_owner, 2, "Walls must be closer together\n");
		LTB_Explode ();
		return;
	}
	if ((trace_ent.team_no == self.team_no))
	{
		self.nextthink = (time + 1);
		self.think = LTB_Arm;
		return;
	}
	if ((self.weapon == 0.000000))
	{
		self.weapon = 1;
	}
	if ((self.attack_finished < time))
	{
		self.movetype = 0.000000;
		self.solid = 2;
		self.takedamage = 1;
		setmodel (self, "progs/beam.mdl");
		self.skin = (self.owner.team_no - 1);
		sound (self, 3, "weapons/tlaser.wav", 0.5, 1);
		self.attack_finished = (time + 0.02);
	}
	self.think = LTB_Arm;
	self.nextthink = (time + 0.07);
	if ((other.team_no == self.team_no))
	{
		return;
	}
	if (((trace_ent.velocity != '0 0 0') || (trace_ent.flags & 32)))
	{
		LTB_Explode ();
		return;
	}
};

void () LTB_Detonate =
{
	self.th_pain = SUB_Null;
	self.th_die = SUB_Null;
	deathmsg = 50;
	T_RadiusDamage (self, self.owner, 200, world);
	sprint (self.real_owner, 1, "Your laser trip wire is gone\n");
	WriteByte (0.000000, 23);
	WriteByte (0.000000, 3);
	WriteCoord (0.000000, self.origin_x);
	WriteCoord (0.000000, self.origin_y);
	WriteCoord (0.000000, self.origin_z);
	BecomeExplosion ();
};

void () LTB_Explode =
{
	sound (self, 3, "weapons/tarbeep.wav", 1, 1);
	self.nextthink = (time + 0.01);
	self.think = LTB_Detonate;
	deathmsg = 50;
};

void () LTB_Pain =
{
	self.nextthink = (time + 0.02);
	self.think = LTB_Detonate;
	self.health = 10;
	deathmsg = 50;
};

void () ParaGlide =
{
	if ((!(self.owner.flags & 512) && (self.owner.chute_active == 1)))
	{
		makevectors (self.owner.v_angle);
		self.owner.velocity = aim (self.owner, 1);
		self.owner.velocity = (self.owner.velocity * 200);
		self.owner.velocity_z = -80.000000;
		self.angles = self.owner.angles;
		setorigin (self, (self.owner.origin + '0 0 45'));
		self.nextthink = (time + 0.01);
		self.think = ParaGlide;
		if ((self.frame < 3))
		{
			if ((self.owner.chute_count < time))
			{
				self.owner.chute_count = (time + 0.1);
				self.frame = (self.frame + 1);
			}
		}
	}
	else
	{
		sound (self, 3, "utils/paraland.wav", 1, 1);
		self.owner.chute_count = 0.000000;
		self.owner.chute_active = 0.000000;
		self.think = SUB_Null;
		remove (self);
	}
};

void () PullCord =
{
	if ((self.chute_active == 1))
	{
		return;
	}
	if ((self.flags & 512))
	{
		return;
	}
	player_run ();
	self.chute_active = 1;
	sound (self, 2, "utils/pullcord.wav", 1, 1);
	newmis = spawn ();
	newmis.movetype = 0.000000;
	newmis.owner = self;
	newmis.solid = 0.000000;
	newmis.nextthink = time;
	newmis.think = ParaGlide;
	newmis.colormap = self.colormap;
	setmodel (newmis, "progs/chute.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	makevectors (self.v_angle);
};

void () FireUtil =
{
	if (((self.playerclass == 8) && self.hook_out))
	{
		sprint (self, 2, "You must retract hook first!\n");
		return;
	}
	if ((self.tools == (self.tools | 32)))
	{
		return;
	}
	if ((self.chute_active == 0.000000))
	{
		if ((self.waterlevel > 0.000000))
		{
			return;
		}
		else
		{
			PullCord ();
		}
	}
};
*/
void () TeamFortress_Discard =
{
	if (self.discard_next > time)
	{
//fixes discard server bug
		return;
	}
	newmis = spawn ();
	if ((self.playerclass == 1.000000))
	{
		newmis.ammo_rockets = self.ammo_rockets;
		self.ammo_rockets = 0.000000;
		if (self.discard_max)
		{
			if ((self.ammo_shells > 10.000000))
			{
				newmis.ammo_shells = (self.ammo_shells - 10.000000);
				self.ammo_shells = 10.000000;
			}
		}
	}
	else
	{
		if ((self.playerclass == 2.000000))
		{
			newmis.ammo_rockets = self.ammo_rockets;
			self.ammo_rockets = 0.000000;
			if (self.discard_max)
			{
				if ((self.ammo_shells > 40.000000))
				{
					newmis.ammo_shells = (self.ammo_shells - 40.000000);
					self.ammo_shells = 40.000000;
				}
			}
		}
		else
		{
			if ((self.playerclass == 3.000000))
			{
				newmis.ammo_cells = self.ammo_cells;
				newmis.ammo_nails = self.ammo_nails;
				self.ammo_cells = 0.000000;
				self.ammo_nails = 0.000000;
				if (self.discard_max)
				{
					if ((self.ammo_shells > 40.000000))
					{
						newmis.ammo_shells = (self.ammo_shells - 40.000000);
						self.ammo_shells = 40.000000;
					}
				}
			}
			else
			{
				if ((self.playerclass == 4.000000))
				{
					newmis.ammo_cells = self.ammo_cells;
					newmis.ammo_nails = self.ammo_nails;
					self.ammo_cells = 0.000000;
					self.ammo_nails = 0.000000;
					if (self.discard_max)
					{
						if ((self.ammo_shells > 40.000000))
						{
							newmis.ammo_shells = (self.ammo_shells - 40.000000);
							self.ammo_shells = 40.000000;
						}
					}
				}
				else
				{
					if ((self.playerclass == 5.000000))
					{
						newmis.ammo_rockets = self.ammo_rockets;
						self.ammo_rockets = 0.000000;
						if (!medicarmorheal)
						{
							newmis.ammo_cells = self.ammo_cells;
							self.ammo_cells = 0.000000;
						}
						if (self.discard_max)
						{
							if ((self.ammo_shells > 40.000000))
							{
								newmis.ammo_shells = (self.ammo_shells - 40.000000);
								self.ammo_shells = 40.000000;
							}
						}
					}
					else
					{
						if ((self.playerclass == 6.000000))
						{
							newmis.ammo_rockets = self.ammo_rockets;
							self.ammo_rockets = 0.000000;
							if (self.discard_max)
							{
								if ((self.ammo_cells > 10.000000))
								{
									newmis.ammo_cells = (self.ammo_cells - 10.000000);
									self.ammo_cells = 10.000000;
								}
							}
						}
						else
						{
							if ((self.playerclass == 7.000000))
							{
								newmis.ammo_nails = self.ammo_nails;
								self.ammo_nails = 0.000000;
								if (self.discard_max)
								{
									if ((self.ammo_shells > 20.000000))
									{
										newmis.ammo_shells = (self.ammo_shells - 20.000000);
										self.ammo_shells = 20.000000;
									}
								}
							}
							else
							{
								if ((self.playerclass == 8.000000))
								{
									newmis.ammo_rockets = self.ammo_rockets;
									self.ammo_rockets = 0.000000;
								}
								else
								{
									if ((self.playerclass == 9.000000))
									{
										newmis.ammo_rockets = self.ammo_rockets;
										self.ammo_rockets = 0.000000;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!(((newmis.ammo_shells + newmis.ammo_nails) + newmis.ammo_rockets) + newmis.ammo_cells))
	{
		dremove (newmis);
		return;
	}
	W_SetCurrentAmmo ();
	sound (self, 3.000000, "weapons/lock4.wav", 1.000000, 1.000000);
	if ((self.team_no != 0.000000))
	{
		increment_team_ammoboxes (self.team_no);
		if ((num_team_ammoboxes (self.team_no) > (20.000000 / number_of_teams)))
		{
			RemoveOldAmmobox (self.team_no);
		}
	}
	else
	{
		num_world_ammoboxes = num_world_ammoboxes + 1.000000;
		if ((num_world_ammoboxes > 20.000000))
		{
			RemoveOldAmmobox (0.000000);
		}
	}
	newmis.enemy = self;
	newmis.health = time;
	newmis.weapon = 0.000000;
	newmis.movetype = 6.000000;
	newmis.solid = 1.000000;
	newmis.classname = "ammobox";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = ((v_forward * 400.000000) + (v_up * 200.000000));
	}
	else
	{
		newmis.velocity = aim (self, 10000.000000);
		newmis.velocity = (newmis.velocity * 400.000000);
		newmis.velocity_z = 200.000000;
	}
	newmis.avelocity = '0.000000 300.000000 0.000000';
	setsize (newmis, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
	setorigin (newmis, self.origin);
	newmis.nextthink = (time + 30.000000);
	newmis.think = SUB_Remove;
	newmis.touch = TeamFortress_AmmoboxTouch;
	setmodel (newmis, "progs/backpack.mdl");
	self.discard_next = time + 0.25;
};

void () TeamFortress_SaveMe =
{
	local entity te;
	local entity tl;

	if ((self.last_saveme_sound < time))
	{
		sound (self, TF_FLARE_OFF, "speech/saveme1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		self.last_saveme_sound = (time + 4);
	}
	te = find (world, classname, "player");
	while (te)
	{
		if (((((self == te) || (te.playerclass == 5)) || (te.playerclass == 9)) || (te.playerclass == 8)))
		{
			if ((((te.team_no == self.team_no) && (self.team_no != TF_FLARE_LIT)) || (te.playerclass == 8)))
			{
				if (visible (te))
				{
					msg_entity = te;
					tl = spawn ();
					tl.origin = self.origin;
					tl.origin_z = (tl.origin_z + 32);
					WriteByte (TF_FLARE_OFF, 23);
					WriteByte (TF_FLARE_OFF, 9);
					WriteEntity (TF_FLARE_OFF, tl);
					WriteCoord (TF_FLARE_OFF, tl.origin_x);
					WriteCoord (TF_FLARE_OFF, tl.origin_y);
					WriteCoord (TF_FLARE_OFF, (tl.origin_z + 24));
					WriteCoord (TF_FLARE_OFF, self.origin_x);
					WriteCoord (TF_FLARE_OFF, self.origin_y);
					WriteCoord (TF_FLARE_OFF, self.origin_z);
					dremove (tl);
				}
			}
		}
		te = find (te, classname, "player");
	}
};

void () TeamFortress_ID =
{
	local vector src;
	local string st;
	local string _l_3386;
	local string cls;

	src = self.origin + (v_forward * 10.000000);
	src_z = self.absmin_z + (self.size_z * 0.700000);
	traceline (src, (src + (v_forward * 2048.000000)), 0.000000, self);
	if (((trace_ent != world) && (trace_ent.origin != world.origin)))
	{
		if (((trace_ent.classname == "player") && (trace_ent.health > 0.000000)))
		{
			if ((trace_ent.bugger > 0.000000))
			{
				return;
			}
			self.StatusRefreshTime = (time + 1.500000);
			if (((self.team_no != 0.000000) && (self.team_no == trace_ent.team_no)))
			{
				cls = TeamFortress_GetClassName (trace_ent.playerclass);
				if ((self.playerclass == 5.000000))
				{
					if (medicarmorheal == 1)
					{
						st = NumberToString1000 (trace_ent.health);
						_l_3386 = NumberToString1000 (trace_ent.armorvalue);
						st = ftos (rint ((((trace_ent.health / trace_ent.max_health) + (trace_ent.armorvalue / trace_ent.maxarmor)) * 50.000000)));
						centerprint (self, "\n\n\n\n\n\n", trace_ent.netname, "\nFriendly ", cls, "\n", st, "% strength\n");
						return;
					}
					else
					{
						st = NumberToString1000 (trace_ent.health);
						centerprint (self, "\n\n\n", trace_ent.netname, "\nFriendly ", cls, "\n", st, " health\n");
						return;
					}
				}
				else
				{
					if ((self.playerclass == 9.000000))
					{
						st = NumberToString1000 (trace_ent.armorvalue);
						centerprint (self, "\n\n\n\n\n\n", trace_ent.netname, "\nFriendly ", cls, "\n", st, " armor\n");
						return;
					}
				}
				centerprint (self, "\n\n\n\n\n\n", trace_ent.netname, "\nFriendly ", cls);
				return;
			}
			if ((trace_ent.playerclass == 8.000000))
			{
				cls = TeamFortress_GetClassName (trace_ent.undercover_skin);
				if (((self.team_no != 0.000000) && (self.team_no == trace_ent.undercover_team)))
				{
					if ((self.playerclass == 5.000000))
					{
						if (medicarmorheal)
						{
							st = NumberToString1000 (trace_ent.health);
							_l_3386 = NumberToString1000 (trace_ent.armorvalue);
							st = ftos (rint ((((trace_ent.health / trace_ent.max_health) + (trace_ent.armorvalue / trace_ent.maxarmor)) * 50.000000)));
							if ((trace_ent.undercover_skin != 0.000000))
							{
								centerprint (self, "\n\n\n\n\n\n", trace_ent.undercover_name, "\nFriendly ", cls, "\n", st, "% strength\n");
							}
							else
							{
								centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nFriendly Spy\n", st, "% strength\n");
							}
							return;
						}
						else
						{
							st = NumberToString1000 (trace_ent.health);
							if ((trace_ent.undercover_skin != 0.000000))
							{
								centerprint (self, "\n\n\n\n", trace_ent.undercover_name, "\nFriendly ", cls, "\n", st, " health\n");
							}
							else
							{
								centerprint (self, "\n\n\n\n", trace_ent.undercover_name, "\nFriendly Spy\n", st, " health\n");
							}
							return;
						}
					}
					else
					{
						if ((self.playerclass == 9.000000))
						{
							st = NumberToString1000 (trace_ent.armorvalue);
							if ((trace_ent.undercover_skin != 0.000000))
							{
								centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nFriendly ", cls, "\n", st, " armor\n");
							}
							else
							{
								centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nFriendly Spy\n", st, " armor\n");
							}
							return;
						}
						else
						{
							st = NumberToString1000 (trace_ent.armorvalue);
							if ((trace_ent.undercover_skin != 0.000000))
							{
								centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nFriendly ", cls);
							}
							else
							{
								centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nFriendly Spy\n");
							}
							return;
						}
					}
				}
				if ((trace_ent.undercover_name != string_null))
				{
					if ((trace_ent.undercover_skin != 0.000000))
					{
						centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nEnemy ", cls);
					}
					else
					{
						centerprint (self, "\n\n\n\n\n\n\n", trace_ent.undercover_name, "\nEnemy Spy");
					}
				}
				else
				{
					if ((trace_ent.undercover_skin != 0.000000))
					{
						centerprint (self, "\n\n\n\n\n\n\n", trace_ent.netname, "\nEnemy ", cls);
					}
					else
					{
						centerprint (self, "\n\n\n\n\n\n\n", trace_ent.netname, "\nEnemy Spy");
					}
				}
			}
			else
			{
				cls = TeamFortress_GetClassName (trace_ent.playerclass);
				centerprint (self, "\n\n\n\n\n\n\n", trace_ent.netname, "\nEnemy ", cls);
			}
		}
		else
		{
			if ((trace_ent.classname == "building_dispenser"))
			{
				self.StatusRefreshTime = (time + 1.500000);
				if ((self == trace_ent.real_owner))
				{
					centerprint (self, "\n\n\n\n\n\n\nYour Dispenser");
				}
				else
				{
					centerprint (self, "\n\n\n\n\n\n\nDispenser made by ", trace_ent.real_owner.netname);
				}
			}
			else
			{
				if (((trace_ent.classname == "building_sentrygun") || (trace_ent.classname == "building_sentrygun_base")))
				{
					self.StatusRefreshTime = (time + 1.500000);
					if ((self == trace_ent.real_owner))
					{
						centerprint (self, "\n\n\n\n\n\n\nYour SentryGun");
					}
					else
					{
						if (!teamplay)
						{
							centerprint (self, "\n\n\n\n\n\n\nSentrygun made by\n", trace_ent.real_owner.netname);
						}
						else
						{
							if (((self.team_no != 0.000000) && (self.team_no == trace_ent.team_no)))
							{
								centerprint (self, "\n\n\n\n\n\n\nFriendly Sentrygun made by\n", trace_ent.real_owner.netname);
							}
							else
							{
								centerprint (self, "\n\n\n\n\n\n\nEnemy Sentrygun made by\n", trace_ent.real_owner.netname);
							}
						}
					}
				}
				else
				{
					if ((trace_ent.classname == "building_tesla"))
					{
						self.StatusRefreshTime = (time + 1.500000);
						if ((self == trace_ent.real_owner))
						{
							centerprint (self, "\n\n\n\n\n\n\nYour Tesla Coil");
						}
						else
						{
							if (!teamplay)
							{
								centerprint (self, "\n\n\n\n\n\n\nTesla Coil made by\n", trace_ent.real_owner.netname);
							}
							else
							{
								if (((self.team_no != 0.000000) && (self.team_no == trace_ent.team_no)))
								{
									centerprint (self, "\n\n\n\n\n\n\nFriendly Tesla made by\n", trace_ent.real_owner.netname);
								}
								else
								{
									centerprint (self, "\n\n\n\n\n\n\nEnemy Tesla made by\n", trace_ent.real_owner.netname);
								}
							}
						}
					}
				}
			}
		}
	}
};

void () TeamFortress_ReloadCurrentWeapon =
{
	local float rt;
	local entity tWeapon;

	if ((self.current_weapon == 128))
	{
		if ((self.reload_shotgun == TF_FLARE_LIT))
		{
			sprint (self, 2, "clip full.\n");
			return;
		}
		if ((self.reload_shotgun < self.ammo_shells))
		{
			Attack_Finished (0.4);
			rt = ((8 - self.reload_shotgun) / 8);
			rt = (2 - (2 * rt));
			self.reload_shotgun = TF_FLARE_LIT;
			if ((self.ammo_shells < 8))
			{
				self.reload_shotgun = (8 - self.ammo_shells);
			}
			sprint (self, 2, "reloading...\n");
			self.tfstate = (self.tfstate | 2);
			tWeapon = spawn ();
			tWeapon.owner = self;
			tWeapon.classname = "timer";
			tWeapon.nextthink = (time + rt);
			tWeapon.think = W_Reload_shotgun;
			self.weaponmodel = "";
			self.weaponframe = TF_FLARE_LIT;
		}
		else
		{
			sprint (self, 2, "not enough ammo to reload\n");
		}
	}
	else
	{
		if ((self.current_weapon == 256))
		{
			if ((self.reload_super_shotgun == TF_FLARE_LIT))
			{
				sprint (self, 2, "clip full.\n");
				return;
			}
			if ((self.reload_super_shotgun < self.ammo_shells))
			{
				Attack_Finished (0.7);
				rt = ((16 - self.reload_super_shotgun) / 16);
				rt = (3 - (3 * rt));
				self.reload_super_shotgun = TF_FLARE_LIT;
				if ((self.ammo_shells < 16))
				{
					self.reload_super_shotgun = (16 - self.ammo_shells);
				}
				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn ();
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = (time + rt);
				tWeapon.think = W_Reload_super_shotgun;
				self.weaponmodel = "";
				self.weaponframe = TF_FLARE_LIT;
			}
			else
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else
		{
			if ((self.current_weapon == 2048))
			{
				if ((self.reload_grenade_launcher == TF_FLARE_LIT))
				{
					sprint (self, 2, "clip full.\n");
					return;
				}
				if ((self.reload_grenade_launcher < self.ammo_rockets))
				{
					Attack_Finished (0.6);
					rt = ((6 - self.reload_grenade_launcher) / 6);
					rt = (4 - (4 * rt));
					self.reload_grenade_launcher = TF_FLARE_LIT;
					if ((self.ammo_rockets < 6))
					{
						self.reload_grenade_launcher = (6 - self.ammo_rockets);
					}
					sprint (self, 2, "reloading...\n");
					self.tfstate = (self.tfstate | 2);
					tWeapon = spawn ();
					tWeapon.owner = self;
					tWeapon.classname = "timer";
					tWeapon.nextthink = (time + rt);
					tWeapon.think = W_Reload_grenade_launcher;
					self.weaponmodel = "";
					self.weaponframe = TF_FLARE_LIT;
				}
				else
				{
					sprint (self, 2, "not enough ammo to reload\n");
				}
			}
			else
			{
				if ((self.current_weapon == 8192))
				{
					if ((self.reload_rocket_launcher == TF_FLARE_LIT))
					{
						sprint (self, 2, "clip full.\n");
						return;
					}
					if ((self.reload_rocket_launcher < self.ammo_rockets))
					{
						Attack_Finished (0.8);
						rt = ((4 - self.reload_rocket_launcher) / 4);
						rt = (5 - (5 * rt));
						self.reload_rocket_launcher = TF_FLARE_LIT;
						if ((self.ammo_rockets < 4))
						{
							self.reload_rocket_launcher = (4 - self.ammo_rockets);
						}
						sprint (self, 2, "reloading...\n");
						self.tfstate = (self.tfstate | 2);
						tWeapon = spawn ();
						tWeapon.owner = self;
						tWeapon.classname = "timer";
						tWeapon.nextthink = (time + rt);
						tWeapon.think = W_Reload_rocket_launcher;
						self.weaponmodel = "";
						self.weaponframe = TF_FLARE_LIT;
					}
				}
			}
		}
	}
};
/*
void () TeamFortress_NightVision =
{
	local entity te;
	local entity tl;

	sound (self, TF_FLARE_LIT, "items/nightvis.wav", 0.5, TF_FLARE_OFF);
	te = find (world, classname, "player");
	while (te)
	{
		if ((self != te))
		{
			if ((te.team_no != TF_FLARE_LIT))
			{
				if ((te.health > TF_FLARE_OFF))
				{
					if (visible (te))
					{
						msg_entity = self;
						tl = spawn ();
						tl.owner = self;
						tl.origin = te.origin;
						tl.origin_z = (tl.origin_z + 32);
						WriteByte (TF_FLARE_OFF, 23);
						WriteByte (TF_FLARE_OFF, 9);
						WriteEntity (TF_FLARE_OFF, tl);
						WriteCoord (TF_FLARE_OFF, tl.origin_x);
						WriteCoord (TF_FLARE_OFF, tl.origin_y);
						WriteCoord (TF_FLARE_OFF, tl.origin_z);
						WriteCoord (TF_FLARE_OFF, te.origin_x);
						WriteCoord (TF_FLARE_OFF, te.origin_y);
						WriteCoord (TF_FLARE_OFF, (te.origin_z + 5));
						dremove (tl);
					}
				}
			}
		}
		te = find (te, classname, "player");
	}
	te = find (world, classname, "building_sentrygun");
	while (te)
	{
		if ((self != te))
		{
			if ((te.team_no != TF_FLARE_LIT))
			{
				if ((te.health > TF_FLARE_OFF))
				{
					if (visible (te))
					{
						msg_entity = self;
						tl = spawn ();
						tl.owner = self;
						tl.origin = te.origin;
						tl.origin_z = (tl.origin_z + 32);
						WriteByte (TF_FLARE_OFF, 23);
						WriteByte (TF_FLARE_OFF, 9);
						WriteEntity (TF_FLARE_OFF, tl);
						WriteCoord (TF_FLARE_OFF, tl.origin_x);
						WriteCoord (TF_FLARE_OFF, tl.origin_y);
						WriteCoord (TF_FLARE_OFF, tl.origin_z);
						WriteCoord (TF_FLARE_OFF, te.origin_x);
						WriteCoord (TF_FLARE_OFF, te.origin_y);
						WriteCoord (TF_FLARE_OFF, (te.origin_z + 5));
						dremove (tl);
					}
				}
			}
		}
		te = find (te, classname, "building_sentrygun");
	}
	te = find (world, classname, "bot");
	while (te)
	{
		if ((self != te))
		{
			if ((te.team_no != TF_FLARE_LIT))
			{
				if ((te.health > TF_FLARE_OFF))
				{
					if (visible (te))
					{
						msg_entity = self;
						tl = spawn ();
						tl.owner = self;
						tl.origin = te.origin;
						tl.origin_z = (tl.origin_z + 32);
						WriteByte (TF_FLARE_OFF, 23);
						WriteByte (TF_FLARE_OFF, 9);
						WriteEntity (TF_FLARE_OFF, tl);
						WriteCoord (TF_FLARE_OFF, tl.origin_x);
						WriteCoord (TF_FLARE_OFF, tl.origin_y);
						WriteCoord (TF_FLARE_OFF, tl.origin_z);
						WriteCoord (TF_FLARE_OFF, te.origin_x);
						WriteCoord (TF_FLARE_OFF, te.origin_y);
						WriteCoord (TF_FLARE_OFF, (te.origin_z + 5));
						dremove (tl);
					}
				}
			}
		}
		te = find (te, classname, "bot");
	}
};

void () Drone =
{
	if (((self.no_grenades_1 < 1) || (self.ammo_cells < 100)))
	{
		sprint (self, 2, "You need 1 Normal Grenade & 100 Armor\n");
		return;
	}
	if ((self.last_used > time))
	{
		sprint (self, 2, "Not finished building new drone yet... takes 3 minutes\n");
		return;
	}
	sprint (self, 2, "Laser Drone away!\n");
	self.last_used = (time + 180);
	self.no_grenades_1 = (self.no_grenades_1 - TF_FLARE_OFF);
	self.ammo_cells = (self.ammo_cells - 100);
	newmis = spawn ();
	newmis.owner = self;
	newmis.weapon = 41;
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.classname = "bot";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = (v_forward * 200);
	}
	else
	{
		newmis.velocity = aim (self, 10000);
		newmis.velocity = (newmis.velocity * 200);
	}
	newmis.option = TF_FLARE_OFF;
	newmis.health = 30;
	newmis.takedamage = 2;
	newmis.th_die = DroneDie;
	setsize (newmis, '-8 -8 -8', '12 12 12');
	setorigin (newmis, ((self.origin + (v_forward * 8)) + '0 0 20'));
	newmis.angles_x = self.angles_x;
	newmis.angles_y = self.angles_y;
	newmis.angles_z = self.angles_z;
	sound (newmis, TF_FLARE_LIT, "weapons/chngnu1a.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis.nextthink = (time + 0.8);
	newmis.playerclass = TF_FLARE_LIT;
	newmis.think = DroneJet;
	newmis.touch = BalloonMIRVtouch;
	newmis.skin = TF_FLARE_LIT;
	setmodel (newmis, "progs/lsrdrone.mdl");
};

void () Drone_Laser_Touch =
{
	local float deflect;
	local vector org;

	if ((other == self.owner))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
//	if ((other.playerclass == 7))
//	{
//		deflect = hwguy_deflect (other);
//		if (deflect)
//		{
//			return;
//		}
//	}
	sound (self, TF_FLARE_OFF, "enforcer/enfstop.wav", TF_FLARE_OFF, 3);
	org = (self.origin - (8 * normalize (self.velocity)));
	if (other.health)
	{
		SpawnBlood (org, 15);
		deathmsg = 41;
		self.weapon = 41;
		if (((other.classname == "building_sentrygun") || (other.classname == "building_tesla")))
		{
			T_RadiusDamage (self, self.owner.owner, 90, world);
		}
		else
		{
			T_Damage (other, self, self.owner.owner, 25);
		}
	}
	dremove (self);
};

void (vector org,vector vec) DroneLaunchLaser =
{
	sound (self, TF_FLARE_OFF, "enforcer/enfire.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	vec = normalize (vec);
	newmis = spawn ();
	newmis.owner = self;
	newmis.team_no = self.team_no;
	newmis.movetype = 5;
	newmis.solid = 2;
	newmis.effects = 8;
	newmis.weapon = 41;
	newmis.classname = "drone_laser";
	newmis.skin = (self.owner.team_no - TF_FLARE_OFF);
	setmodel (newmis, "progs/beam.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = (vec * 2000);
	newmis.angles = vectoangles (newmis.velocity);
	newmis.nextthink = (time + 4);
	newmis.think = SUB_Remove;
	newmis.touch = Drone_Laser_Touch;
};

void () DroneDoneTouch =
{
	if (self.velocity_z)
	{
		sound (self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
};

void () DroneDie =
{
	ThrowGib ("progs/tgib2.mdl", -70.000000);
	ThrowGib ("progs/dgib2.mdl", -70.000000);
	ThrowGib ("progs/dgib3.mdl", -70.000000);
	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);
	multicast (self.origin, TF_FLARE_OFF);
	BecomeExplosion ();
};

void () DroneFall =
{
	sound (self, TF_FLARE_LIT, "weapons/chngnu1a.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	self.movetype = 10;
	self.avelocity = '200 0 300';
	setsize (self, '-8 -8 -8', '8 8 8');
	self.takedamage = 2;
	self.skin = TF_FLARE_OFF;
	// pablo. why change it's team? just causes problems.
	//self.team_no = 5;
	self.th_die = DroneDie;
	self.touch = DroneDoneTouch;
	self.think = DroneDie;
	self.nextthink = (time + 20);
};

void () DroneJet =
{
	local entity te;
	local entity tl;

	self.playerclass = (self.playerclass + TF_FLARE_OFF);
	self.nextthink = (time + 0.9);
	sound (self, TF_FLARE_LIT, "weapons/drone.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	te = find (world, classname, "player");
	while (te)
	{
		if ((self != te))
		{
			if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
			{
				if (te.health)
				{
					if (visible (te))
					{
						if ((te.is_undercover != TF_FLARE_OFF))
						{
							DroneLaunchLaser (self.origin, (te.origin - self.origin));
						}
					}
				}
			}
		}
		te = find (te, classname, "player");
	}
	te = find (world, classname, "building_sentrygun");
	while (te)
	{
		if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
		{
			if (te.health)
			{
				if (visible (te))
				{
					DroneLaunchLaser (self.origin, ((te.origin + '0 0 24') - self.origin));
				}
			}
		}
		te = find (te, classname, "building_senrygun");
	}
//	te = find (world, classname, "building_tesla");
//	while (te)
//	{
//		if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
//		{
//			if (te.health)
//			{
//				if (visible (te))
//				{
//					DroneLaunchLaser (self.origin, ((te.origin + '0 0 24') - self.origin));
//				}
//			}
//		}
//		te = find (te, classname, "building_tesla");
//	}
	te = find (world, classname, "bot");
	while (te)
	{
		if ((self != te))
		{
			if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
			{
				if (te.health)
				{
					if (visible (te))
					{
						DroneLaunchLaser (self.origin, (te.origin - self.origin));
					}
				}
			}
		}
		te = find (te, classname, "bot");
	}
	if ((self.playerclass > 10))
	{
		self.think = DroneFall;
	}
};

vector (vector ang) SUB_NormalizeAngles =
{
	while ((ang_x > 360))
	{
		ang_x = (ang_x - 360);
	}
	while ((ang_x < TF_FLARE_LIT))
	{
		ang_x = (ang_x + 360);
	}
	while ((ang_y > 360))
	{
		ang_y = (ang_y - 360);
	}
	while ((ang_y < TF_FLARE_LIT))
	{
		ang_y = (ang_y + 360);
	}
	while ((ang_z > 360))
	{
		ang_z = (ang_z - 360);
	}
	while ((ang_z < TF_FLARE_LIT))
	{
		ang_z = (ang_z + 360);
	}
	return (ang);
};

void () Prox_Disarm =
{
	if ((other.classname != "player"))
	{
		return;
	}
	if (((other.playerclass == 1.000000) && (other.team_no != self.team_no)))
	{
		sound (other, 2.000000, "items/flare1.wav", 1.000000, 1.000000);
		other.real_frags = (other.real_frags + 1.000000);
		dremove (self);
	}
	return;
};

void () ProxiDie =
{
	self.effects = 4;
	make_explosion ();
	self.takedamage = TF_FLARE_LIT;
	deathmsg = 45;
	T_RadiusDamage (self, self.owner, 200, world);
	sprint (self.owner, 2, "Your Proxi Mine is gone...\n");
	dremove (self);
};

void () FoundBastard =
{
	local float _l_11382;

	self.touch = Prox_Disarm;
	sound (self, 3.000000, "effects/beep.wav", 1.000000, 1.000000);
	self.skin = (self.owner.team_no + 3.000000);
	_l_11382 = vlen ((self.enemy.origin - self.origin));
	if ((_l_11382 <= self.height))
	{
		self.height = _l_11382;
		self.nextthink = (time + ((_l_11382 / 1000.000000) * 1.500000));
		self.think = FoundBastard;
	}
	else
	{
		self.effects = 4.000000;
		make_explosion ();
		MushroomFlame ();
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 3.000000);
		WriteCoord (4.000000, self.origin_x);
		WriteCoord (4.000000, self.origin_y);
		WriteCoord (4.000000, self.origin_z);
		multicast (self.origin, 1.000000);
		deathmsg = 45.000000;
		self.takedamage = 0.000000;
		T_RadiusDamage (self, self.owner, 200.000000, world);
		dremove (self);
	}
};

void () ProxArmed =
{
	local entity _l_11392;
	local entity _l_11393;
	local vector _l_11394;

	self.velocity = '0.000000 0.000000 0.000000';
	self.nextthink = (time + 1.000000);
	self.think = ProxArmed;
	sound (self, 3.000000, "effects/beep.wav", 0.300000, 1.000000);
	self.playerclass = (self.playerclass + 1.000000);
	if ((self.skin == self.owner.team_no))
	{
		self.skin = 0.000000;
	}
	else
	{
		self.skin = self.owner.team_no;
	}
	_l_11392 = find (world, classname, "player");
	while (_l_11392)
	{
		if ((self.owner != _l_11392))
		{
			if ((((_l_11392.team_no != 0.000000) && (_l_11392.team_no != self.team_no)) && (_l_11392.bugger == 0.000000)))
			{
				if ((_l_11392.health > 1.000000))
				{
					if (visible (_l_11392))
					{
						if ((_l_11392.undercover_team != self.team_no))
						{
							_l_11394 = _l_11392.origin - self.origin;
							if ((vlen (_l_11394) < 200.000000))
							{
								self.height = vlen (_l_11394);
								self.enemy = _l_11392;
								self.nextthink = 0.200000;
								self.think = FoundBastard;
							}
						}
					}
				}
			}
		}
		_l_11392 = find (_l_11392, classname, "player");
	}
	if (((self.playerclass > 300.000000) || (self.owner.playerclass != 3.000000)))
	{
		dremove (self);
	}
};

void () ProxAttach =
{

	self.think = ProxArmed;
	self.nextthink = (time + 0.500000);
	sound (newmis, 0.000000, "buttons/switch02.wav", 1.000000, 1.000000);
};

void () Prox =
{
	local vector _l_11458;
	local vector _l_11461;
	local entity _l_11464;

	_l_11464 = find (world, classname, "bot");
	while (_l_11464)
	{
		if ((_l_11464.owner == self))
		{
			local float proxyDistance = vlen(_l_11464.origin - self.origin);
			if (proxyDistance < 40)
			{
				dremove(_l_11464);
				if (self.no_grenades_2 < 3.000000)
				{
					self.no_grenades_2 = (self.no_grenades_2 + 2.000000);
				}
				return;
			}
			else
			{
				sprint (self, 2.000000, "1 proximity grenade at a time!\n");
				if ((self.weaponmodel == "progs/proxgren.mdl"))
				{
					self.current_weapon = W_BestWeapon ();
					self.weaponmodel = "progs/v_rock2.mdl";
					self.currentammo = self.ammo_rockets;
					Attack_Finished (0.700000);
					self.impulse = 0.000000;
					self.StatusRefreshTime = (time + 0.100000);
				}
				return;
			}
		}
		_l_11464 = find (_l_11464, classname, "bot");
	}
	if ((self.no_grenades_2 < 2.000000))
	{
		sprint (self, 2.000000, "Not enough type 2 grenades... get more\n");
		if ((self.weaponmodel == "progs/proxgren.mdl"))
		{
			self.weaponmodel = "progs/v_rock2.mdl";
			self.currentammo = self.ammo_rockets;
			Attack_Finished (0.700000);
			self.impulse = 0.000000;
			self.StatusRefreshTime = (time + 0.100000);
			self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
		}
		return;
	}
	if ((self.weaponmodel != "progs/proxgren.mdl"))
	{
		self.tfstate = (self.tfstate | 2.000000);
		self.oldweaponmodel = self.weaponmodel;
		self.oldcurrentammo = self.currentammo;
		self.currentammo = 1.000000;
		self.weaponmodel = "progs/proxgren.mdl";
		self.weaponframe = 0.000000;
		return;
	}
	makevectors (self.v_angle);
	_l_11458 = self.origin + (v_forward * 10.000000);
	_l_11458_z = self.absmin_z + (self.size_z * 0.700000);
	traceline (_l_11458, (_l_11458 + (v_forward * 70.000000)), 0.000000, self);
	_l_11461 = trace_endpos - (v_forward * 8.000000);
	if ((trace_fraction != 1.000000))
	{
		sound (self, 3.000000, "buttons/switch02.wav", 1.000000, 1.000000);
		sprint (self, 2.000000, "Proximity mine set!\n");
		self.no_grenades_2 = (self.no_grenades_2 - 2.000000);
		newmis = spawn ();
		newmis.owner = self;
		newmis.weapon = 41.000000;
		newmis.movetype = 0.000000;
		newmis.solid = 2.000000;
		newmis.classname = "bot";
		newmis.netname = "proxi";
		newmis.team_no = self.team_no;
		newmis.health = 3.000000;
		newmis.takedamage = 2.000000;
		newmis.th_die = ProxiDie;
		setsize (newmis, '-3.000000 -3.000000 -3.000000', '3.000000 3.000000 3.000000');
		newmis.angles = '0.000000 0.000000 0.000000';
		newmis.nextthink = (time + 1.000000);
		newmis.playerclass = 0.000000;
		newmis.think = ProxAttach;
		newmis.skin = 0.000000;
		newmis.frame = 1.000000;
		setmodel (newmis, "progs/proxgren.mdl");
		setorigin (newmis, _l_11461);
		if ((self.oldweaponmodel != ""))
		{
			self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
		}
		self.weaponmodel = self.oldweaponmodel;
		self.currentammo = self.oldcurrentammo;
		Attack_Finished (0.700000);
		self.impulse = 0.000000;
		self.StatusRefreshTime = (time + 0.100000);
	}
};

void (vector _p_11412, float _p_11415) BigAssBullet =
{
	local vector _l_11416;
	local vector _l_11419;

	makevectors (self.v_angle);
	_l_11419 = self.origin + (v_forward * 10);
	_l_11419_z = self.absmin_z + (self.size_z * 0.700000);
	ClearMultiDamage ();
	traceline (_l_11419, (_l_11419 + (_p_11412 * 1500)), 0, self);
	if ((trace_fraction != 1))
	{
		TraceAttack (_p_11415, _p_11412);
	}
	if (trace_ent.takedamage)
	{
		_l_11416 = trace_endpos - (v_forward * 4);
		SpawnBlood (_l_11416, 9);
	}
	else
	{
		_l_11416 = trace_endpos - (v_forward * 4);
		WriteByte (4, 23);
		WriteByte (4, 0);
		WriteCoord (4, _l_11416_x);
		WriteCoord (4, );
		WriteCoord (4, );
		multicast (self.origin, 1);
	}
	ApplyMultiDamage ();
};

void () W_FireBigAss =
{
	local vector _l_11430;
	local float _l_11436;

	if ((self.ammo_shells < 10))
	{
		make_explosion ();
		sprint (self, 2, "Ammo chamber jammed!\n");
		sound (self, 1, "weapons/asscan4.wav", 1, 1);
		stuffcmd (self, "bf\n");
		self.option4 = 0;
		return;
	}
	self.nojumptime = (time + 0.750000);
	sound (self, 1, "weapons/20mm.wav", 1, 1);
	KickPlayer (-5, self);
	muzzleflash ();
	stuffcmd (self, "bf\n");
	self.ammo_shells = (self.ammo_shells - 10);
	self.currentammo = (self.ammo_shells - 10);
	makevectors (self.v_angle);
	_l_11430 = v_forward;
	deathmsg = 46;
	BigAssBullet (_l_11430, 50);
	EjectShell ();
	self.velocity = (self.velocity - (v_forward * 200));
	if ((self.ammo_shells == 0))
	{
		self.ammo_shells = 1;
	}
};

void () BigAssCarry =
{
	makevectors (self.owner.v_angle);
	setorigin (self, (((self.owner.origin + (v_forward * 12)) + '0 0 20') + (v_right * 5)));
	self.angles = self.owner.angles;
	self.think = BigAssCarry;
	self.nextthink = (time + 0.02);
};

/*void () MakeBall =
{
	local string st;
	local float tc;
	local float ctr;
	local entity te;

	ctr = 0.000000;
	te = find (world, classname, "ball");
	while (te)
	{
		te.movetype = 10;
		ctr = (ctr + 1);
		te = find (te, classname, "ball");
	}
	if ((ctr < 1))
	{
		newmis = spawn ();
		setmodel (newmis, "progs/s_light.spr");
		newmis.movetype = 10;
		setsize (newmis, '-16 -16 -14', '16 16 16');
		newmis.solid = 1;
		newmis.classname = "ball";
		newmis.touch = BallTouch;
		newmis.think = BallCheck;
		newmis.nextthink = (time + 2);
		makevectors (self.v_angle);
		if (self.v_angle_x)
		{
			newmis.velocity = ((v_forward * 400) + (v_up * 200));
		}
		else
		{
			newmis.velocity = aim (self, 10000);
			newmis.velocity = (newmis.velocity * 400);
			newmis.velocity_z = 200;
		}
		setorigin (newmis, self.origin);
	}
};

void () TeamFortress_shield =
{
	if ((self.playerclass != 7))
	{
		return;
	}
	if ((self.shieldOn == 0.000000))
	{
		sprint (self, 1, "Force Shield Activated\n");
		self.shieldOn = 1;
	}
	else
	{
		sprint (self, 1, "Force Shield De-activated\n");
		self.shieldOn = 0.000000;
	}
};
*/
void () CanisterTouch =
{
	sound (self, 1, "weapons/tink1.wav", 1, 1);
	if ((self.velocity == '0 0 0'))
	{
		self.avelocity = '0 0 0';
	}
};
