//.string areaname;
//.float material;

//string _delaydata;

.string LightningEnd;
.string LightningStart;

.vector rendercolor;
//.float renderamt;


.string LaserTarget;

void () info_target = {

};

void () item_healthkit = {

   self.origin_z = self.origin_z + 40;
   item_health ();
};

void() lightning_fire = {

   local entity te;


   te = find (world,targetname,self.LaserTarget);


   if (te) {

      sound (self,2.000,"misc/power.wav",1.000,1.000);

      WriteByte (4.000,23.000);
      WriteByte (4.000,6.000);
      WriteEntity(4.000, self);
	WriteCoord (4.000, self.origin_x);
	WriteCoord (4.000, self.origin_y);
	WriteCoord (4.000, self.origin_z);
	WriteCoord (4.000, te.origin_x);
	WriteCoord (4.000, te.origin_y);
      WriteCoord (4.000, te.origin_z);
      multicast (self.origin ,1.000);



   }
   else
   {
      dprint (te.classname);
      dprint (" missing laser targets\n");

   }
   

};

void () laser_use = {

   if (self.spawnflags & 1.000) {

      lightning_fire();
      self.spawnflags = (self.spawnflags - 1.000);
   }
   else 
   {
      SUB_Null();
      self.spawnflags = (self.spawnflags + 1.000);
   }

};

void () env_laser = {

//dremove(self);
   self.use = laser_use;

};


void () Explode = {

   WriteByte (4.000,23.000);
   WriteByte (4.000,3.000);
   WriteCoord (4.000,self.origin_x);
   WriteCoord (4.000,self.origin_y);
   WriteCoord (4.000,self.origin_z);
   multicast (self.origin,1.000);

};

void () env_explosion = {

  self.use = Explode;

};

void () env_glow = {

   dremove(self);

};


void () FadeUse {

   eprint(activator);
}

void () env_fade = {

   self.use = FadeUse;

};


void () env_beam_use = {


   if ( (self.spawnflags & 1.000) ) {

      self.solid = 0.000;
      setmodel (self, string_null);
      self.spawnflags = (self.spawnflags - 1.000);

   } else {


      self.solid = 1.000;
      setmodel (self,self.mdl);
      self.spawnflags = (self.spawnflags + 1.000);

   }

};

void () beam_delayed_spawn = {

   local vector orgStart;
   local vector orgEnd;
   local entity te;

   te = find( world, targetname,self.LightningStart);

   if (te != world)
   {
//dprint("found start\n");
      orgStart = te.origin;
   }

   te = find( world, targetname, self.LightningEnd);

   if (te != world)
   {
      orgEnd = te.origin;
//dprint("found end\n");
    }

   if (orgStart)
     setorigin(self, orgStart);

   self.angles = vectoangles (orgEnd - orgStart);
   //self.angles = vectoangles (orgEnd);


   self.think = SUB_Null;
};

void () env_beam = {

   self.solid = 1.000;
   self.movetype = 5.000;

   if ( self.mdl ) {

      precache_model (self.mdl);

   } else {
      precache_model ("progs/beam.mdl");
      self.mdl = "progs/beam.mdl";
      //if (self.team_no = 2.000
   }

   
//beams have a set destination in code and generated by 
//each vector specified in halflife. Unfortunately this 
//isnt a feature i have so we must be a bit dodgy and 
//use a beam model and try to correct its orientation

   self.use = env_beam_use;
   self.think = beam_delayed_spawn;
   self.nextthink = (time + 3.000);

   if (self.rendercolor_z < self.rendercolor_x) 
      self.skin = 1.000;
  
   if (self.spawnflags & 1.000) {
  
      setmodel (self,self.mdl);
   }
};


void () Item_Use = {

      if ( (self.use != SUB_Null) )
      {
         if ( self.use )
         {

            self.use ();
         }
      }

};


void () Delayed_Use = {

   local entity t;
   local entity ste;
              
   t = find (world,targetname, self.target);
   if ( t )
   { 
      //bprint2(2.000, t.classname, " delayed 2\n");


         ste = self;
         self = t;

         if ( (self.use != SUB_Null) ) {

            if ( self.use ) {

               self.use ();

            }

         }
         self = ste;

   }


   //else
  // {
  //    bprint(2.000,t.target);
  //    bprint(2.000,"  ");
  //    bprint2(2.000, t.classname, " not found \n");

   //}

};


void () multi_spawn = {

  local string key;
  local string value;
  local float args;
  local entity t;
  local entity timer;
  local float stlen;
  local string st;
 

  tokanize(self.netname);
  args = argc() - 2; 

  while(args>0)
  {

   key = (argv(args - 1));
   value = (argv(args));


     if ((((key != "classname") && (key != "targetname")) && (key != "origin")))
     {
        self.target = key;
        self.delay = stof(value);

        st = strstr (key, "#1");

        if (st != string_null)
        {
            stlen = strlen (key);
            key = substr(self.target , 0 , stlen - 2);
        }


               //  bprint(2.000,key);
               //  bprint(2.000,"  ");
               //  bprint2(2.000, ftos(stlen), "\n");

        if (self.delay)
        {
              
           if (stlen)
           {

              timer = spawn ();
              timer.classname = "DelayedTimer";
              timer.target = newstr(key, stlen);
              timer.nextthink = (time + self.delay);
              timer.think = Delayed_Use;

           }
           else
           {
              t = find (world,targetname, key);
              if ( t )
              { 

                 t.nextthink = (time + self.delay);
                 t.think = Item_Use;
              }


           }

        }
        else
        {

           SUB_UseTargets();
        }
      stlen = 0.000;
     }

     args = args - 2;
  }



}; 


void () multi_manager = {


 if (__fullspawndata != "")
 {
    dprint("MULTI MANAGER spawned!\n");
    self.use = multi_spawn;
    self.netname = __fullspawndata;

 }
 else
  dprint("no server support for multi_manager\n");



};

void () bomb_target_touch = {


   if (!modetype & 4) return;

   if (other.is_detpacking) {

       TeamFortress_SetBomb(other);
       other.target = self.target;
   }

};


void () SplashTouch = {

  if (other.classname != "player") return;

      other.watertype = -3;
      other.waterlevel = 1;

};

void () func_water = {

if (mapname == "openfire" || mapname == "tfc_openfire") 
   dremove(self);
   
   self.solid = 1.000;
   self.movetype = 0.000;
   //setorigin (self,self.origin);
   setmodel (self,self.model);
   self.touch = SplashTouch;

};


void() func_ladder = {
	self.movetype = 0.000;
	self.solid = 5.000;
	setmodel(self, self.model);
	self.model = "";
};



void () Breakaway  = {

      self.solid = 0.000;
      setmodel (self,string_null);
 };


void () Breakuse = {


   if ( (self.spawnflags & 1.000) ) {

      Breakaway();
      self.spawnflags = (self.spawnflags - 1.000);

   } else {

      self.solid = 4.000;
      setmodel (self,self.mdl);
      self.spawnflags = (self.spawnflags + 1.000);
   }

};

void () Breaktouch = {

  if (other.classname != "player") return;

      Breakaway();

};
 

void () func_breakable = {


	self.solid = 4.000;
	self.movetype = 7.000;
	setorigin (self, self.origin);
      self.mdl = self.model;
	setmodel (self, self.mdl);
	setsize (self, self.mins , self.maxs);


    if (self.spawnflags & 1.000){ 

      if (self.targetname)

         self.use = Breakuse; 

     } else {

         if (self.health) {
            self.takedamage = 1.000;
            self.th_die = Breakaway;
         }
      }
      if (self.spawnflags & 2.000){ 

         self.touch = Breaktouch;
      }


};


void () func_wall_toggle = {


   self.movetype = 7.000;
   self.solid = 4.000;
   if (self.targetname)
      self.use = Breakuse; 
   self.mdl = self.model;
   setmodel (self,self.mdl);
   self.spawnflags = 1.000;
};



void () info_areadef = {

   dremove(self);

};  

void () infodecal = {

   dremove(self);

};  


void () trigger_camera = {

   self.classname = "info_player_start";

};




